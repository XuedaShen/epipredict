% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_population_scaling.R
\name{step_population_scaling}
\alias{step_population_scaling}
\title{Create a recipe step that scales variables using population data}
\usage{
step_population_scaling(
  recipe,
  ...,
  df,
  by = NULL,
  df_pop_col,
  inputs = NULL,
  create_new = TRUE,
  suffix = "_scaled",
  role = "predictor",
  trained = FALSE,
  skip = FALSE,
  id = rand_id("population_scaling")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe. The recipe should contain information about the
\code{epi_df} such as column names.}

\item{...}{the corresponding column(s) in the \code{epi_df} that will be scaled.}

\item{df}{a data frame that contains the population data used for scaling.}

\item{by}{A character vector of variables to join by.

If \code{NULL}, the default, the function will perform a natural join, using all
variables in common across the \code{epi_df} and the user-provided dataset.
If columns in \code{epi_df} and \code{df} have the same name (and aren't
included in by), suffixes \code{.x} and \code{.y} are added to disambiguate.

To join by different variables on the \code{epi_df} and \code{df}, use a named vector.
For example, by = c("geo_value" = "states") will match \code{epi_df$geo_value}
to \code{df$states}. To join by multiple variables, use a vector with length > 1.
For example, by = c("geo_value" = "states", "county" = "county") will match
\code{epi_df$geo_value} to \code{df$states} and \code{epi_df$county} to \code{df$county}.}

\item{df_pop_col}{the name of the column in the data frame \code{df} that
contains the population data and will be used for scaling.
This should be one column, and column names should be in lower case.}

\item{inputs}{Quosure(s) of \code{...}.}

\item{create_new}{TRUE to create a new column and keep the original column
in the \code{epi_df}}

\item{suffix}{a character. The suffix added to the column name if
\code{crete_new = TRUE}. Default to "_scaled".}

\item{role}{For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from the
original variables will be used as predictors in a model. Other options can
be ard are not limited to "outcome".}

\item{trained}{A logical to indicate if the quantities for preprocessing
have been estimated.}

\item{skip}{A logical. Should the step be skipped when the
recipe is baked by \code{\link[=bake]{bake()}}? While all operations are baked
when \code{\link[=prep]{prep()}} is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using \code{skip = TRUE} as it may affect
the computations for subsequent operations.}

\item{id}{A unique identifier for the step}
}
\value{
Scales raw data by the population
}
\description{
\code{step_population_scaling} creates a specification of a recipe step
that will add a population scaled column in the data. For example,
load a dataset that contains county population, and join to an \code{epi_df}
that currently only contains number of new cases by county. Once scaled,
predictions can be made on case rate. Although worth noting that there is
nothing special about "population". The function can be used to scale by any
variable. Population is simply the most natural and common use case.
}
\examples{
library(epiprocess)
library(epipredict)
jhu <- epiprocess::jhu_csse_daily_subset \%>\%
  dplyr::filter(time_value > "2021-11-01", geo_value \%in\% c("ca", "ny")) \%>\%
  dplyr::select(geo_value, time_value, cases)

pop_data = data.frame(states = c("ca", "ny"),
                      value = c(20000, 30000))

r <- epi_recipe(jhu) \%>\%
  step_population_scaling(df = pop_data,
                          df_pop_col = "value",
                          by = c("geo_value" = "states"),
                          cases, suffix = "_scaled") \%>\%
  step_epi_lag(cases_scaled, lag = c(7, 14)) \%>\%
  step_epi_ahead(cases_scaled, ahead = 7, role = "outcome") \%>\%
  step_epi_naomit()

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_threshold(.pred) \%>\%
  layer_naomit(.pred) \%>\%
  layer_population_scaling(.pred, df = pop_data,
                           by =  c("geo_value" = "states"),
                           df_pop_col = "value")

wf <- epi_workflow(r,
                   parsnip::linear_reg()) \%>\%
  parsnip::fit(jhu) \%>\%
  add_frosting(f)

latest <- get_test_data(recipe = r,
                        x = epiprocess::jhu_csse_daily_subset \%>\%
                          dplyr::filter(time_value > "2021-11-01",
                                        geo_value \%in\% c("ca", "ny")) \%>\%
                          dplyr::select(geo_value, time_value, cases))


predict(wf, latest)
}
