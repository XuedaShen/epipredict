% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_predict.R
\name{layer_predict}
\alias{layer_predict}
\title{Prediction layer for postprocessing}
\usage{
layer_predict(
  frosting,
  type = NULL,
  opts = list(),
  ...,
  .flag = TRUE,
  id = rand_id("predict_default")
)
}
\arguments{
\item{frosting}{a frosting object
#' @param .flag a logical to determine if the layer is added. Passed on to
\code{add_layer()}. Default \code{TRUE}.}

\item{type}{A single character value or \code{NULL}. Possible values
are "numeric", "class", "prob", "conf_int", "pred_int", "quantile", "time",
"hazard", "survival", or "raw". When \code{NULL}, \code{predict()} will choose an
appropriate value based on the model's mode.}

\item{opts}{A list of optional arguments to the underlying
predict function that will be used when \code{type = "raw"}. The
list should not include options for the model object or the
new data being predicted.}

\item{...}{Arguments to the underlying model's prediction
function cannot be passed here (see \code{opts}). There are some
\code{parsnip} related options that can be passed, depending on the
value of \code{type}. Possible arguments are:
\itemize{
\item \code{interval}: for \code{type}s of "survival" and "quantile", should
interval estimates be added, if available? Options are \code{"none"}
and \code{"confidence"}.
\item \code{level}: for \code{type}s of "conf_int", "pred_int", and "survival"
this is the parameter for the tail area of the intervals
(e.g. confidence level for confidence intervals).
Default value is 0.95.
\item \code{std_error}: add the standard error of fit or prediction (on
the scale of the linear predictors) for \code{type}s of "conf_int"
and "pred_int". Default value is \code{FALSE}.
\item \code{quantile}: the quantile(s) for quantile regression
(not implemented yet)
\item \code{time}: the time(s) for hazard and survival probability estimates.
}}

\item{.flag}{a logical to determine if the layer is added. Passed on to
\code{add_layer()}. Default \code{TRUE}.}

\item{id}{a string identifying the layer}
}
\value{
An updated \code{frosting} object
}
\description{
Implements prediction on a fitted \code{epi_workflow}. One may want different
types of prediction, and to potentially apply this after some amount of
postprocessing. This would typically be the first layer in a \code{frosting}
postprocessor.
}
\examples{
library(dplyr)
library(recipes)

jhu <- case_death_rate_subset \%>\%
filter(time_value > "2021-11-01", geo_value \%in\% c("ak", "ca", "ny"))
r <- epi_recipe(jhu) \%>\%
 step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
 step_epi_ahead(death_rate, ahead = 7) \%>\%
 step_naomit(all_predictors()) \%>\%
 step_naomit(all_outcomes(), skip = TRUE)
wf <- epi_workflow(r, parsnip::linear_reg()) \%>\% parsnip::fit(jhu)
latest <- jhu \%>\%
 filter(time_value >= max(time_value) - 14)

# Predict layer alone
f <- frosting() \%>\% layer_predict()
wf1 <- wf \%>\% add_frosting(f)

p1 <- predict(wf1, latest)
p1

# Prediction with interval
f <- frosting() \%>\% layer_predict(type = "pred_int")
wf2 <- wf \%>\% add_frosting(f)

p2 <- predict(wf2, latest)
p2
}
\seealso{
\code{parsnip::predict.model_fit()}
}
