% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_population_scaling.R
\name{layer_population_scaling}
\alias{layer_population_scaling}
\title{Revert population scaled prediction}
\usage{
layer_population_scaling(
  frosting,
  ...,
  df,
  by = NULL,
  df_pop_col,
  create_new = TRUE,
  suffix = "_original",
  .flag = TRUE,
  id = rand_id("population_scaling")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor}

\item{...}{the column(s) in the \code{epi_df} to scale back.}

\item{df}{a data frame that contains the population data used for scaling.}

\item{by}{A character vector of variables to join by.

If \code{NULL}, the default, the function will perform a natural join, using all
variables in common across the \code{epi_df} and the user-provided dataset.
If columns in \code{epi_df} and \code{df} have the same name (and aren't
included in by), suffixes \code{.x} and \code{.y} are added to disambiguate.

To join by different variables on the \code{epi_df} and \code{df}, use a named vector.
For example, by = c("geo_value" = "states") will match \code{epi_df$geo_value}
to \code{df$states}. To join by multiple variables, use a vector with length > 1.
For example, by = c("geo_value" = "states", "county" = "county") will match
\code{epi_df$geo_value} to \code{df$states} and \code{epi_df$county} to \code{df$county}.}

\item{df_pop_col}{the name of the column in the data frame \code{df} that
contains the population data and used for scaling.}

\item{create_new}{TRUE to create a new column and keep the original column
in the \code{epi_df}.}

\item{suffix}{a character. The suffix added to the column name if
\code{create_new = TRUE}. Default to "_original".}

\item{.flag}{a logical to determine if the layer is added. Passed on to
\code{add_layer()}. Default \code{TRUE}.}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor
}
\description{
Revert population scaled prediction
}
\examples{
library(epiprocess)
jhu <- epiprocess::jhu_csse_daily_subset \%>\%
  dplyr::filter(time_value > "2021-11-01", geo_value \%in\% c("ca", "ny")) \%>\%
  dplyr::select(geo_value, time_value, cases)

pop_data = data.frame(states = c("ca", "ny"),
                      value = c(20000, 30000))

r <- epi_recipe(jhu) \%>\%
  step_population_scaling(df = pop_data,
                          df_pop_col = "value",
                          by = c("geo_value" = "states"),
                          cases, suffix = "_scaled") \%>\%
  step_epi_lag(cases_scaled, lag = c(7, 14)) \%>\%
  step_epi_ahead(cases_scaled, ahead = 7, role = "outcome") \%>\%
  step_epi_naomit()

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_threshold(.pred) \%>\%
  layer_naomit(.pred) \%>\%
  layer_population_scaling(.pred, df = pop_data,
                           by =  c("geo_value" = "states"),
                           df_pop_col = "value")

wf <- epi_workflow(r,
                   parsnip::linear_reg()) \%>\%
  parsnip::fit(jhu) \%>\%
  add_frosting(f)

latest <- get_test_data(recipe = r,
                        x = epiprocess::jhu_csse_daily_subset \%>\%
                          dplyr::filter(time_value > "2021-11-01",
                                        geo_value \%in\% c("ca", "ny")) \%>\%
                          dplyr::select(geo_value, time_value, cases))


predict(wf, latest)
}
