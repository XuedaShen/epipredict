% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_population_scaling.R
\name{layer_population_scaling}
\alias{layer_population_scaling}
\title{Revert population scaled prediction}
\usage{
layer_population_scaling(
  frosting,
  ...,
  df,
  by = NULL,
  df_pop_col,
  create_new = TRUE,
  suffix = "_original",
  .flag = TRUE,
  id = rand_id("population_scaling")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor. The layer will be added to the
sequence of operations  for this frosting.}

\item{...}{One or more selector functions to scale variables
for this step. See \code{\link[=selections]{selections()}} for more details.}

\item{df}{a data frame that contains the population data used for scaling.}

\item{by}{A character vector of variables to left join by.

If \code{NULL}, the default, the function will perform a natural join, using all
variables in common across the \code{epi_df} and the user-provided dataset.
If columns in \code{epi_df} and \code{df} have the same name (and aren't
included in by), \code{.df} is added to the one from the user-provided data
to disambiguate.

To join by different variables on the \code{epi_df} and \code{df}, use a named vector.
For example, by = c("geo_value" = "states") will match \code{epi_df$geo_value}
to \code{df$states}. To join by multiple variables, use a vector with length > 1.
For example, by = c("geo_value" = "states", "county" = "county") will match
\code{epi_df$geo_value} to \code{df$states} and \code{epi_df$county} to \code{df$county}.

See \code{\link[dplyr:mutate-joins]{dplyr::left_join()}} for more details.}

\item{df_pop_col}{the name of the column in the data frame \code{df} that
contains the population data and used for scaling.}

\item{create_new}{TRUE to create a new column and keep the original column
in the \code{epi_df}.}

\item{suffix}{a character. The suffix added to the column name if
\code{create_new = TRUE}. Default to "_original".}

\item{.flag}{a logical to determine if the layer is added. Passed on to
\code{add_layer()}. Default \code{TRUE}.}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor
}
\description{
\code{layer_population_scaling} creates a specification of a frosting layer
that will add a population scaled column in the data. For example,
load a dataset that contains county population, and join to an \code{epi_df}
that currently predicts number of new cases by county to obtain case rates.
Although worth noting that there is nothing special about "population".
The function can be used to scale by any variable. Population is simply the
most natural and common use case.
}
\examples{
library(epiprocess)
jhu <- epiprocess::jhu_csse_daily_subset \%>\%
  dplyr::filter(time_value > "2021-11-01", geo_value \%in\% c("ca", "ny")) \%>\%
  dplyr::select(geo_value, time_value, cases)

pop_data = data.frame(states = c("ca", "ny"),
                      value = c(20000, 30000))

r <- epi_recipe(jhu) \%>\%
  step_population_scaling(df = pop_data,
                          df_pop_col = "value",
                          by = c("geo_value" = "states"),
                          cases, suffix = "_scaled") \%>\%
  step_epi_lag(cases_scaled, lag = c(7, 14)) \%>\%
  step_epi_ahead(cases_scaled, ahead = 7, role = "outcome") \%>\%
  step_epi_naomit()

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_threshold(.pred) \%>\%
  layer_naomit(.pred) \%>\%
  layer_population_scaling(.pred, df = pop_data,
                           by =  c("geo_value" = "states"),
                           df_pop_col = "value")

wf <- epi_workflow(r,
                   parsnip::linear_reg()) \%>\%
  parsnip::fit(jhu) \%>\%
  add_frosting(f)

latest <- get_test_data(recipe = r,
                        x = epiprocess::jhu_csse_daily_subset \%>\%
                          dplyr::filter(time_value > "2021-11-01",
                                        geo_value \%in\% c("ca", "ny")) \%>\%
                          dplyr::select(geo_value, time_value, cases))


predict(wf, latest)
}
