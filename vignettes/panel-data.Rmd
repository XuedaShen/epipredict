---
title: "Using epipredict on non-epidemic panel data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using epipredict on non-epidemic panel data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

```{r libraries}
library(epiprocess)
library(epipredict)
library(dplyr)
library(stringr)
library(parsnip)
library(recipes)
```

[Panel data](https://en.wikipedia.org/wiki/Panel_data), or longitudinal data, 
contains cross-sectional measurements of subjects over time. The `epipredict` 
package is most suitable for running forecasters on epidemiological panel data. 
A built-in example of this is the [`case_death_rate_subset`](
  https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html) 
dataset, which contains daily state-wise measures of `case_rate` and 
`death_rate` for COVID-19 in 2021:

```{r epi-panel-ex, include=T}
head(case_death_rate_subset)
```

`epipredict` functions work with data in [`epi_df`](
  https://cmu-delphi.github.io/epiprocess/reference/epi_df.html) 
format. Despite the stated goal and name of the package, other panel datasets 
are also valid candidates for `epipredict` functionality. Specifically, the 
`epipredict` framework and direct forecasters are able to work with any panel 
data, as long as it's in `epi_df` format, 

```{r employ-stats, include=F}
year_start <- min(grad_employ_subset$time_value)
year_end <- max(grad_employ_subset$time_value)
```

## Example panel data overview

In this vignette, we will demonstrate using `epipredict` with employment data 
from Statistics Canada. We will be using 
[
  Table 37-10-0115-01: Characteristics and median employment income of 
  longitudinal cohorts of postsecondary graduates two and five years after 
  graduation, by educational qualification and field of study (primary 
  groupings)
](https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=3710011501). 
The full dataset contains yearly median employment income two and five years 
after graduation, and number of graduates. The data is further stratified by 
variables such as geographic region (Canadian province), field of study, and 
age group. The year range of the dataset is `r year_start` to `r year_end`, 
inclusive. The full dataset also contains metadata that describes the 
quality of data collected. For demonstration purposes, we make the following 
modifications to get a subset of the full dataset:

* Only keep provincial-level geographic region (the full data also has 
"Canada" as a region)
* Only keep "good" or better quality data rows, as indicated by the [`STATUS`]
(https://www.statcan.gc.ca/en/concepts/definitions/guide-symbol) column
* Choose a subset of covariates and aggregate across the remaining ones. The 
chosen covariates are age group, field of study, and educational qualification.

Below is the query for obtaining the full data and code for subsetting it as we 
just described:

```{r employ-query, eval=F}
library(cansim)

statcan_grad_employ <- get_cansim("37-10-0115-01")
gemploy <- statcan_grad_employ %>% 
  select(c("REF_DATE", "GEO", "VALUE", "STATUS", "Educational qualification", 
    "Field of study", "Gender", "Age group", "Status of student in Canada", 
    "Characteristics after graduation", "Graduate statistics")) %>%
  rename(
    "geo_value" = "GEO",
    "time_value" = "REF_DATE",
    "value" = "VALUE",
    "status" = "STATUS",
    "edu_qual" = "Educational qualification",
    "fos" = "Field of study",
    "gender" = "Gender",
    "age_group" = "Age group",
    "student_status" = "Status of student in Canada",
    "grad_charac" = "Characteristics after graduation",
    "grad_stat" = "Graduate statistics") %>%
  # The original `VALUE` column contain the statistic indicated by 
  # `Graduate statistics` in the original data. Below we pivot the data 
  # wider so that each unique statistic can have its own column.
  mutate(
    grad_stat = recode_factor(
      grad_stat, 
      `Number of graduates` = "num_graduates", 
      `Median employment income two years after graduation` = "med_income_2y",
      `Median employment income five years after graduation` = "med_income_5y"),
    time_value = as.integer(time_value)
  ) %>%
  pivot_wider(names_from = grad_stat, values_from = value) %>%
  filter(
    # Drop aggregates for some columns
    geo_value != "Canada" & 
    age_group != "15 to 64 years" &
    fos != "Total, field of study" &
    edu_qual != "Total, educational qualification" &
    # Keep aggregates for keys we don't want to keep
    gender == "Total, gender" &
    student_status == "Canadian and international students" &
    # Since we're looking at 2y and 5y employment income, the only 
    # characteristics remaining are:
    # - Graduates reporting employment income
    # - Graduates reporting wages, salaries, and commissions only
    # For simplicity, keep the first one only 
    grad_charac == "Graduates reporting employment income" &
    # Only keep "good" data
    is.na(status) & 
    # Drop NA value rows 
    !is.na(num_graduates) & !is.na(med_income_2y) & !is.na(med_income_5y)) %>%
  select(-c(status, gender, student_status, grad_charac))
```

To use this data with `epipredict`, we need to convert it into `epi_df` format 
using [`as_epi_df`](
  https://cmu-delphi.github.io/epiprocess/reference/as_epi_df.html) 
with additional keys. In our case, the additional keys are `age_group`, `fos` 
and `edu_qual`. Note that in the above modifications, we encoded `time_value` 
as type `integer`. This allows us to set `time_type` to `"year"`, and to ensure 
lag and ahead modifications later on are using the correct time units.

```{r convert-to-epidf, eval=F}
grad_employ_subset <- gemploy %>%
  tsibble::as_tsibble(
    index=time_value, 
    key=c(geo_value, age_group, fos, edu_qual)) %>%
  as_epi_df(
    geo_type = "custom", time_type = "year",
    additional_metadata=c(other_keys=list("age_group", "fos", "edu_qual")))
```

```{r data-dim, include=F}
employ_rowcount <- format(nrow(grad_employ_subset), big.mark=",")
employ_colcount <- length(names(grad_employ_subset))
```

The data contains `r employ_rowcount` rows and `r employ_colcount` columns. Now, 
we are ready to use `grad_employ_subset` with `epipredict`. 

```{r preview-data, include=T}
# Rename for simplicity
employ <- grad_employ_subset
sample_n(employ, 6)
```

In the following sections, we will go over preprocessing the data in the 
`epi_recipe` framework, and fitting a model and making predictions within the 
`epipredict` framework and using the package's canned forecasters.

## Preprocessing 

We will create a recipe that adds one `ahead` column and 3 `lag` columns.

```{r make-recipe, include=T}
r <- epi_recipe(employ) %>%
  step_epi_ahead(num_graduates, ahead = 1) %>% # lag & ahead units in years
  step_epi_lag(num_graduates, lag = c(0, 1, 1)) %>%
  step_epi_naomit() 
r
```

There is one `raw` role which includes our value column `num_graduates`, and two 
`key` roles which include our additional keys `age_group`, `fos` and 
`edu_qual`. Let's take a look at what these additional columns look like.

```{r view-preprocessed, include=T}
# Display a sample of the preprocessed data
baked_sample <- r %>% prep() %>% bake(new_data = employ) %>% sample_n(5)
baked_sample
```

## Model fitting and prediction

### Within recipes framework 

We will look at a simple model: `parsnip::linear_reg()` with default engine 
`lm`. We can use `epi_workflow` with the `epi_recipe` we defined in the 
preprocessing section to fit an autoregressive linear model using lags at
time $t$ (current), $t-1$ (last year), and $t-2$ (2 years ago).

```{r linearreg-wf, include=T}
wf_linreg <- epi_workflow(r, parsnip::linear_reg()) %>% fit(employ)
wf_linreg
```

Now that we have our workflow, we can generate predictions from a subset of our 
data. For this demo, we will predict the employment counts from the last 12
months of our dataset.

```{r linearreg-predict, include=T}
latest <- employ %>% filter(time_value >= max(time_value) - 12)
preds <- stats::predict(wf_linreg, latest) %>% filter(!is.na(.pred))
# Display a sample of the prediction values
head(preds)
```

Notice that `predict` still returns an `epi_df` with all of the keys that were 
present in the original dataset. 

### With canned forecasters

Even though we aren't working with epidemiological data, canned forecasters 
still work as expected, out of the box. We will demonstrate this with the simple
[`flatline_forecaster`](
  https://cmu-delphi.github.io/epipredict/reference/flatline_forecaster.html) 
and the direct autoregressive (AR) forecaster 
[`arx_forecaster`](
  https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html).

```{r flatline, include=T}
out_fl <- flatline_forecaster(employ, "med_income_2y", 
  args_list = flatline_args_list(
    ahead=1L, forecast_date = as.Date("2022-08-16")))

augment(out_fl$epi_workflow, employ)
```

```{r arx, include=T}
arx_args <- arx_args_list(
    lags = c(0L, 1L, 2L), ahead = 1L, forecast_date = as.Date("2022-08-01"))
out_arx <- arx_forecaster(employ, "med_income_2y", 
  c("med_income_2y", "med_income_5y", "num_graduates"), 
  args_list = arx_args)

out_arx$predictions 
```

Other changes to the direct AR forecaster, like changing the engine, also work 
as expected.

```{r arx-epi-rf, include=F, warning=F}
out_rf <- arx_forecaster(
  employ, "med_income_2y", c("med_income_2y", "med_income_5y"), 
  trainer = parsnip::rand_forest(mode="regression", trees=100),
  args_list = args)

out_rf$predictions 
```
