---
title: Apply other steps and models from recipes and parsnip packages
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Apply other steps and models from recipes and parsnip packages}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
The `epipredict` package utilizes the `tidymodels` framework, namely 
[`recipes`](https://recipes.tidymodels.org/) for 
[dplyr](https://dplyr.tidyverse.org/)-like pipeable sequences 
of feature engineering and [`parsnip`](https://parsnip.tidymodels.org/) for a 
unified interface to a range of models. 

`epipredict` has additional customized feature engineering and preprocessing steps 
tailored to fit the needs of epidemiology forecasting, such as `step_epi_shift()`, 
`step_population_scaling()`, `step_epi_naomit()`. They can be used along with 
steps from the `recipes` package for more feature engineering. 

In this vignette, we will demonstrate how to weave `recipes` steps and `parsnip`
models into the `epipredict` workflow. 

```{r, warning=FALSE, message =FALSE}
library(epipredict)
library(epiprocess)
library(recipes)
library(parsnip)
library(workflows)
```

We will use the built-in dataset `case_death_rate_subset` and apply feature 
engineering steps and fit a few models from `parsnip` to predict future death 
rates by states. 
```{r}
x <- case_death_rate_subset
head(x)
```
There are `r dim(x)[1]` rows and `r dim(x)[2]` columns in the data, with dates
ranging from `r min(x$time_value)` to `r max(x$time_value)` in 
`r n_distinct(x$geo_value)` states in the U.S.

# Preprocessing and Feature Engineering

In this section, we focus on showing how `step_*()` functions from the `recipes`
package can also be applied in our `epipredict` workflows. 

First, create a recipe object from the original data and then specify the 
preprocessing steps. Steps are then sequentially added.

```{r create-recipe-object}
r <- epi_recipe(x)
r
```

The function automatically categorizes roles into `geo_value`, `time_value` and 
`raw` based on variable names, where `raw` includes `case_rate` and `death_rate`. 

We first create a made-up population dataset by states to allow the conversion
from `case_rate` and `death_rate` into `cases` and  `deaths`. The binary variable
`social_distancing` indicates whether the state followed social distancing rules.
A 'throw-away' column with all ones is also created to show that `step_rm()` 
can be used to remove unwanted columns.
```{r madeup-population-data}
pop_data <- data.frame(states = unique(x$geo_value),
                       inv_pop = 1/seq(1e5, 1e7, length.out = n_distinct(x$geo_value)),
                       social_distancing = rbinom(n = n_distinct(x$geo_value), 
                                                  size = 1,
                                                  prob = 0.5),
                       throw_away = 1)

head(pop_data)
```

Next, we will feature engineer `case_rate` and `death_rate` into `cases` and 
`deaths`and create lags and leads based on them. 

```{r create-new-columns-in-recipe}
r <- r %>%
  step_population_scaling(case_rate, death_rate, df = pop_data, 
                          by = c("geo_value" = "states"),
                          create_new = FALSE,
                          df_pop_col = "inv_pop") %>%
  step_rename(cases = case_rate, deaths = death_rate) %>%
  step_rm(throw_away) %>%
  step_epi_lag(cases, lag = c(0, 7, 14), role = "predictor") %>%
  step_epi_lag(deaths, lag = c(0, 7, 14), role = "predictor") %>%
  step_epi_ahead(deaths, ahead = 7, role = "outcome") %>%
  step_epi_naomit() 

```

Notice that `step_rename()` was used for renaming of the variables, and `step_rm()`
was used to remove redundant columns.

A quick view of what the prepossessed data looks like on training data:

```{r peak-data-1}
slice_sample(bake(prep(r, x),x), n = 6)
```
There are also many functions in the `recipes` package that allow for 
spline transformation or other types of function transformations. 

```{r, warning=FALSE}
r <- r %>% 
  step_sqrt(contains("lag_")) %>%
  step_rm(cases, deaths)
  

slice_sample(bake(prep(r, x),x), n = 6)
```


Sometimes, the exact counts are desired so fitting a linear regression would be 
a good idea. On the other hand, instead of predicting 
7-day ahead death counts, we would like to predict if the death counts 7 days 
from the latest date fall into some categories. For the purpose of illustration, 
we define two categories: less than 10K(low) and more than 10K(high). 

We can resort to the `recipes` package again:

```{r, warning = FALSE}
binner <- function(x) {
  x <- cut(x, breaks = c(0, 10000, Inf), include.lowest = TRUE)
  # now return the group number
  as.numeric(x)
}

inc <- c("low", "high")

r_categorical <- r %>% 
  step_num2factor(ahead_7_deaths, 
                  role = "outcome", 
                  transform = binner, 
                  levels = inc)

slice_sample(bake(prep(r_categorical, x),x), n = 6)
```



# Model Fitting

Once the pre-processing steps are done, we can move on to model fitting using 
the `parsnip` package. 

First, we can try fitting a linear regression:

```{r linear-fit}
wf <- epi_workflow(r, parsnip::linear_reg()) %>%
    fit(x) 
# the fit
wf$fit
latest <- get_test_data(recipe = r, x = x)
p <- predict(wf, latest) %>% filter(!is.na(.pred))
p
```


Logistic Regression
```{r poisson}
wf <- epi_workflow(r_categorical, parsnip::logistic_reg()) %>%
    fit(x) 
# the fit
wf$fit
latest <- get_test_data(recipe = r_categorical, x = x)
p <- predict(wf, latest) %>% filter(!is.na(.pred_class))
p
```



## Issues from vignette
1. `step_cut()` did not work
```{r, error=TRUE}
r_test1 <- epi_recipe(x) %>%
  step_population_scaling(case_rate, death_rate, df = pop_data, 
                          by = c("geo_value" = "states"),
                          create_new = FALSE,
                          df_pop_col = "inv_pop") %>%
  step_rename(cases = case_rate, deaths = death_rate) %>%
  step_rm(throw_away) %>%
  step_epi_lag(cases, lag = c(0, 7, 14), role = "predictor") %>%
  step_epi_lag(deaths, lag = c(0, 7, 14), role = "predictor") %>%
  step_epi_ahead(deaths, ahead = 7, role = "outcome") %>%
  step_epi_naomit() %>%
  step_cut(ahead_7_deaths, role = "outcome", breaks= c(0, 10000, Inf))

slice_sample(bake(prep(r_test1, x),x), n = 6)
```
2. Predictions are not produced, despite different models applied to it. Perhaps
something wrong with the preprocessing steps?
Maybe without `step_population_scaling()`:
```{r}
r_test2 <- epi_recipe(x) %>%
  step_epi_lag(case_rate, lag = c(0, 7, 14), role = "predictor") %>%
  step_epi_lag(death_rate, lag = c(0, 7, 14), role = "predictor") %>%
  step_epi_ahead(death_rate, ahead = 7, role = "outcome") %>%
  step_naomit(all_predictors()) %>%
  step_naomit(all_outcomes(), skip = TRUE)

slice_sample(bake(prep(r_test2, x),x), n = 6)

wf <- epi_workflow(r_test2, parsnip::linear_reg()) %>%
    fit(x) 
# the fit
wf$fit
latest <- get_test_data(recipe = r_test2, x = x)
# latest <- x %>%
#   filter(!is.na(case_rate), !is.na(death_rate)) %>%
#   group_by(geo_value) %>%
#   slice_tail(n = 15) %>% # have lags 0,...,14, so need 15 for a complete case
#   ungroup()
p <- predict(wf, latest)  %>% filter(!is.na(.pred))
p

```


