[{"path":"https://cmu-delphi.github.io/epipredict/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 epipredict authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"goals-for-the-package","dir":"Articles","previous_headings":"","what":"Goals for the package","title":"Get started with epipredict","text":"high level, goal epipredict make running simple Machine Learning / Statistical forecasters epidemiology easy. However, package extremely extensible, part utility. hope easy users epi training statistics fit baseline models still allowing nuanced statistical understanding create complicated specializations within framework. Serving populations main motivation efforts, time, tried hard make useful.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"baseline-models","dir":"Articles","previous_headings":"Goals for the package","what":"Baseline models","title":"Get started with epipredict","text":"provide set basic, easy--use forecasters work box. able reasonably limited amount customization . serious customization happens framework discussed ). basic forecasters, provide, least: Baseline flat-line forecaster Autoregressive forecaster Autoregressive classifier forcasters provide built framework. use basic models illustrate flexibility.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"forecasting-framework","dir":"Articles","previous_headings":"Goals for the package","what":"Forecasting framework","title":"Get started with epipredict","text":"framework creating custom forecasters views prediction task set modular components. four types components: Preprocessor: make transformations data model training Trainer: train model data, resulting fitted model object Predictor: make predictions, using fitted model object processed test data Postprocessor: manipulate transform predictions returning Users familiar {tidymodels} especially {workflows} package notice lot overlap. design, fact feature. truth epipredict wrapper around much contained packages. Therefore, want something -verse, “just work” (hope). reason overlap workflows already implements first three steps. well. However, missing postprocessing stage currently plans implementation. feature important. baseline forecaster provide requires postprocessing. Anything complicated needs well. second omission tidymodels support panel data. Besides epidemiological data, economics, psychology, sociology, many areas frequently deal data type. framework behind epipredict implements . principle, nothing epidemiology, one simply use package solution missing functionality tidymodels. , “just work”. panel data functionality implemented epi_df data type companion {epiprocess} package. much see , moment, ’s enough look simple one: data built package contains measured variables case_rate death_rate COVID-19 daily level US state year 2021. “panel” part repeated measurements across number locations. epi_df encodes timestamp time_value key geo_value. 2 names required, values don’t need actually represent objects. Additional key’s also supported (like age group, ethnicity, taxonomy, etc.). epi_df also contains metadata describes keys well vintage data. ’s possible data collected different times set geo_value’s time_value’s actually different. details, see {epiprocess}.","code":"jhu <- case_death_rate_subset jhu #> An `epi_df` object, 20,496 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 20,496 × 4 #>    geo_value time_value case_rate death_rate #>  * <chr>     <date>         <dbl>      <dbl> #>  1 ak        2020-12-31      35.9      0.158 #>  2 al        2020-12-31      65.1      0.438 #>  3 ar        2020-12-31      66.0      1.27  #>  4 as        2020-12-31       0        0     #>  5 az        2020-12-31      76.8      1.10  #>  6 ca        2020-12-31      96.0      0.751 #>  7 co        2020-12-31      35.8      0.649 #>  8 ct        2020-12-31      52.1      0.819 #>  9 dc        2020-12-31      31.0      0.601 #> 10 de        2020-12-31      65.2      0.807 #> # … with 20,486 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"why-doesnt-this-package-already-exist","dir":"Articles","previous_headings":"Goals for the package","what":"Why doesn’t this package already exist?","title":"Get started with epipredict","text":"described : Parts actually exist. ’s universe called tidymodels. handles preprocessing, training, prediction, bound together, package called workflows. built epipredict top setup. way, CAN use almost everything provide. However, workflows doesn’t postprocessing. nothing -verse handles panel data. tidy-team doesn’t plans either things. (checked). two packages time series built tidymodels, ’s “basic” time series: 1-step AR models, exponential smoothing, STL decomposition, etc.1 never found models particularly helpful epidemic forecasting, one also integrate methods framework.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"show-me-the-basics","dir":"Articles","previous_headings":"","what":"Show me the basics","title":"Get started with epipredict","text":"start jhu data displayed . One “canned” forecasters provide autoregressive forecaster (without) covariates directly trains response. contrast typical “iterative” AR model trains predict one-step-ahead, plugs predictions “leverage ” longer horizons. ’ll estimate model jointly across locations using recent 30 days. call produces warning, ’ll ignore now. essentially, ’s telling us data comes May 2022 ’re trying forecast January 2022. result likely accurate measure real-time forecast performance, data revised time. object two components: predictions just another epi_df. contains predictions location along additional columns. default, 90% predictive interval, forecast_date (date forecast putatively made) target_date (date forecast made). list object class epi_workflow. object encapsulates instructions necessary create prediction. details . Note time_value predictions necessarily meaningful. default, forecaster predicts outcome (death_rate) 1-week ahead, using 3 lags predictor (case_rate death_rate) 0 (today), 1 week back 2 weeks back. predictors outcome can changed directly. rest defaults encapsulated list arguments. list produced arx_args_list().","code":"jhu <- jhu %>% filter(time_value >= max(time_value) - 30) out <- arx_forecaster(jhu, outcome = \"death_rate\",   predictors = c(\"case_rate\", \"death_rate\") ) #> Warning: The forecast_date is less than the most recent update date of the #> data.forecast_date = 2021-12-31 while data is from 2022-05-31. out$predictions #> An `epi_df` object, 56 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 56 × 6 #>    geo_value time_value  .pred         .pred_distn forecast_date target_date #>  * <chr>     <date>      <dbl>              <dist> <date>        <date>      #>  1 ak        2021-12-31 0.355  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  2 al        2021-12-31 0.325  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  3 ar        2021-12-31 0.496  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  4 as        2021-12-31 0.0836 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  5 az        2021-12-31 0.614  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  6 ca        2021-12-31 0.327  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  7 co        2021-12-31 0.567  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  8 ct        2021-12-31 0.544  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  9 dc        2021-12-31 0.831  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #> 10 de        2021-12-31 0.607  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #> # … with 46 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"simple-adjustments","dir":"Articles","previous_headings":"Show me the basics","what":"Simple adjustments","title":"Get started with epipredict","text":"Basic adjustments can made args_list. , ’ve used different lags case_rate now predicting 2 weeks ahead. example also illustrates major difficulty “iterative” versions AR models. model doesn’t produce forecasts case_rate, , data “plug ” necessary lags.2 Another property basic model predictive interval. describe detail different vignette, easy request multiple quantiles. column .pred_dstn predictions object actually “distribution” parameterized quantiles. default forecaster, created using quantiles residuals predictive model (possibly symmetrized). , used 23 quantiles, one can grab particular quantile extract entire distribution “long” epi_df tau probability q value associated quantile. simple adjustments can made using function.","code":"out2week <- arx_forecaster(jhu, \"death_rate\", c(\"case_rate\", \"death_rate\"),   args_list = arx_args_list(     lags = list(c(0,1,2,3,7,14), c(0,7,14)),     ahead = 14)   ) out_q <- arx_forecaster(jhu, \"death_rate\", c(\"case_rate\", \"death_rate\"),   args_list = arx_args_list(     levels = c(.01,.025, seq(.05,.95, by=.05), .975,.99))   ) quantile(out_q$predictions$.pred_distn, p = .4) #>  [1] 0.30277798 0.27213225 0.44345734 0.03120647 0.56121844 0.27492711 #>  [7] 0.51430056 0.49120831 0.77848153 0.55495289 0.48839266 0.46180302 #> [13] 0.07918930 0.43615338 0.40663040 0.28162468 0.57850502 0.56627752 #> [19] 0.30001474 0.46951123 0.27225320 0.66554111 0.69608309 0.52042519 #> [25] 0.70229211 0.46022990 0.41987177 0.79384854 0.26213745 0.22011830 #> [31] 0.29346069 0.37322885 0.24361881 0.60897213 0.73297489 0.62186100 #> [37] 0.29896242 0.82208954 0.94772676 0.34392120 0.23395627 0.73122297 #> [43] 0.46576662 0.73187551 0.28782081 0.38799709 1.51371557 0.26602132 #> [49] 0.24202363 0.49969641 0.42031752 0.38191502 0.24043297 0.58681706 #> [55] 0.55890563 0.26891251 out_q$predictions %>%    mutate(     .pred_distn = nested_quantiles(.pred_distn) # \"nested\" list-col   ) %>% unnest(.pred_distn) #> An `epi_df` object, 1,288 x 7 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 1,288 × 7 #>    geo_value time_value .pred      q   tau forecast_date target_date #>  * <chr>     <date>     <dbl>  <dbl> <dbl> <date>        <date>      #>  1 ak        2021-12-31 0.355 0      0.01  2021-12-31    2022-01-07  #>  2 ak        2021-12-31 0.355 0      0.025 2021-12-31    2022-01-07  #>  3 ak        2021-12-31 0.355 0.0371 0.05  2021-12-31    2022-01-07  #>  4 ak        2021-12-31 0.355 0.123  0.1   2021-12-31    2022-01-07  #>  5 ak        2021-12-31 0.355 0.174  0.15  2021-12-31    2022-01-07  #>  6 ak        2021-12-31 0.355 0.211  0.2   2021-12-31    2022-01-07  #>  7 ak        2021-12-31 0.355 0.237  0.25  2021-12-31    2022-01-07  #>  8 ak        2021-12-31 0.355 0.260  0.3   2021-12-31    2022-01-07  #>  9 ak        2021-12-31 0.355 0.282  0.35  2021-12-31    2022-01-07  #> 10 ak        2021-12-31 0.355 0.303  0.4   2021-12-31    2022-01-07  #> # … with 1,278 more rows arx_args_list(   lags = c(0L, 7L, 14L), ahead = 7L, min_train_window = 20L,    forecast_date = NULL, target_date = NULL, levels = c(0.05, 0.95),   symmetrize = TRUE, nonneg = TRUE, quantile_by_key = TRUE )"},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"changing-the-engine","dir":"Articles","previous_headings":"Show me the basics","what":"Changing the engine","title":"Get started with epipredict","text":"far, forecasts produced using simple linear regression. way estimate model. trainer argument determines type model want. takes {parsnip} model. default linear regression, instead use random forest ranger package: boosted regression trees xgboost:","code":"out_rf <- arx_forecaster(jhu, \"death_rate\", c(\"case_rate\", \"death_rate\"),   rand_forest(mode = \"regression\")) out_gb <- arx_forecaster(jhu, \"death_rate\", c(\"case_rate\", \"death_rate\"),   boost_tree(mode = \"regression\", trees = 20))"},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"inner-workings","dir":"Articles","previous_headings":"Show me the basics","what":"Inner workings","title":"Get started with epipredict","text":"Underneath hood, forecaster creates (returns) epi_workflow. Essentially, big S3 object wraps 4 modular steps (preprocessing - postprocessing) described .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"preprocessing","dir":"Articles","previous_headings":"Show me the basics > Inner workings","what":"Preprocessing","title":"Get started with epipredict","text":"Preprocessing accomplished recipe (imagine baking cake) provided {recipes} package. ’ve made modifications (handle panel data) well added additional options. recipe gives specification handle training data. Think like fancified formula pass lm(): y ~ x1 + log(x2). general, 2 extensions formula recipes handles: transformations training test data can always applied. things like taking log variable, leading lagging, filtering rows, handling dummy variables, etc. Using statistics training data eventually process test data. major benefit recipes. prevents tidy team calls “data leakage”. simple example centering predictor ’s mean. need store mean predictor training data use value test data rather accidentally calculating mean test predictor. recipe processed 2 steps, first “prepped”. calculates stores result necessary use test data. “baked” resulting training data ready passing statistical model (like lm). introduced epi_recipe. ’s just recipe knows handle time_value, geo_value, additional keys available necessary. epi_recipe out_gb can extracted result: “Inputs” original epi_df “roles” assigned. None predictors outcomes. created recipe prepped. “Operations” sequence instructions create cake. create lagged predictors, lead outcome, remove NA’s. models like lm internally handle NA’s, everything , deal explicitly. code (inside forecaster) recipes provides function step_lag(), assumes data breaks sequence time_values. bit dangerous, avoid behaviour. lag/ahead functions also appropriately adjust amount data avoid accidently dropping recent predictors test data.","code":"extract_recipe(out_gb$epi_workflow) #> Recipe #>  #> Inputs: #>  #>        role #variables #>   geo_value          1 #>         raw          2 #>  time_value          1 #>  #> Training data contained 1736 data points and no missing data. #>  #> Operations: #>  #> Lagging case_rate [trained] by 0, 7, 14 #> Lagging death_rate [trained] by 0, 7, 14 #> Leading death_rate [trained] by 7 #> Removing rows with NA values in lag_0_case_rate, lag_7_case_rate, lag_14_case_r... [trained] #> Removing rows with NA values in ahead_7_death_rate [trained] er <- epi_recipe(jhu) %>%   step_epi_lag(case_rate, death_rate, lag = c(0,7,14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()"},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"the-model-specification","dir":"Articles","previous_headings":"Show me the basics > Inner workings","what":"The model specification","title":"Get started with epipredict","text":"Users familiarity parsnip package trouble . Basically, parsnip unifies function signature across statistical models. example, lm() “likes” work formulas, glmnet::glmnet() uses x y predictors response. parsnip agnostic. “linear regression”. switched lm() xgboost() without issue despite fact functions couldn’t different. epipredict provides engines/modules (flatline forecaster quantile regression), able use available models listed . estimate (fit) preprocessed model, one calls fit() epi_workflow.","code":"lm(formula, data, subset, weights, na.action, method = \"qr\",      model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,      contrasts = NULL, offset, ...) xgboost(data = NULL, label = NULL, missing = NA, weight = NULL,      params = list(), nrounds, verbose = 1, print_every_n = 1L,      early_stopping_rounds = NULL, maximize = NULL, save_period = NULL,      save_name = \"xgboost.model\", xgb_model = NULL, callbacks = list(),      ...) ewf <- epi_workflow(er, linear_reg()) %>% fit(jhu)"},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"postprocessing","dir":"Articles","previous_headings":"Show me the basics > Inner workings","what":"Postprocessing","title":"Get started with epipredict","text":"stretch metaphor preparing cake natural limits, created postprocessing functionality called “frosting”. Much like recipe, postprocessing operation “layer” “slather” onto baked cake. fix ideas, postprocessing frosting arx_forecaster() 5 layers frosting. first generates forecasts test data. second uses quantiles residuals (geo_value) create distributional forecasts. next two add columns date forecast made date intended occur. predicting rates, non-negative, last layer thresholds predicted values intervals 0. code (inside forecaster) predict time, add object onto epi_workflow call predict()","code":"extract_frosting(out_q$epi_workflow) #> 5 Frosting Layers #>  #> • layer_predict() #> • layer_residual_quantiles() #> • layer_add_forecast_date() #> • layer_add_target_date() #> • layer_threshold() f <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles(     probs = c(.01,.025, seq(.05,.95, by=.05), .975,.99),      symmetrize = TRUE) %>%   layer_add_forecast_date() %>%   layer_add_target_date() %>%   layer_threshold(starts_with(\".pred\")) test_data <- get_test_data(er, jhu) ewf %>% add_frosting(f) %>% predict(test_data) #> An `epi_df` object, 56 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 56 × 6 #>    geo_value time_value  .pred         .pred_distn forecast_date target_date #>  * <chr>     <date>      <dbl>              <dist> <date>        <date>      #>  1 ak        2021-12-31 0.355  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #>  2 al        2021-12-31 0.325  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #>  3 ar        2021-12-31 0.496  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #>  4 as        2021-12-31 0.0836 [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #>  5 az        2021-12-31 0.614  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #>  6 ca        2021-12-31 0.327  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #>  7 co        2021-12-31 0.567  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #>  8 ct        2021-12-31 0.544  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #>  9 dc        2021-12-31 0.831  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #> 10 de        2021-12-31 0.607  [0.01, 0.99]<q-rng> 2021-12-31    2022-01-07  #> # … with 46 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/articles/epipredict.html","id":"conclusion","dir":"Articles","previous_headings":"Show me the basics","what":"Conclusion","title":"Get started with epipredict","text":"Internally, provide simple functions create reasonable forecasts. ideally, user create forecasters building components provide. vignettes, try walk customizations. illustrate everything , (roughly) code flatline_forecaster() applied case_rate. really differs arx_forecaster() recipe, test data, engine. frosting identical, fitting predicting procedure.","code":"r <- epi_recipe(jhu) %>%   step_epi_ahead(case_rate, ahead = 7, skip = TRUE) %>%   update_role(case_rate, new_role = \"predictor\") %>%   add_role(all_of(epi_keys(jhu)), new_role = \"predictor\")  # bit of a weird hack to get the latest values per key latest <- get_test_data(epi_recipe(jhu), jhu)   f <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles() %>%   layer_add_forecast_date() %>%   layer_add_target_date() %>%   layer_threshold(starts_with(\".pred\"))  eng <- linear_reg() %>% set_engine(\"flatline\") wf <- epi_workflow(r, eng, f) %>% fit(jhu) preds <- predict(wf, latest) preds #> An `epi_df` object, 56 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 56 × 6 #>    geo_value time_value .pred         .pred_distn forecast_date target_date #>  * <chr>     <date>     <dbl>              <dist> <date>        <date>      #>  1 ak        2021-12-31  36.4 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  2 al        2021-12-31  89.9 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  3 ar        2021-12-31  82.6 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  4 as        2021-12-31   0   [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  5 az        2021-12-31  58.3 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  6 ca        2021-12-31  84.4 [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  7 co        2021-12-31 106.  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  8 ct        2021-12-31 143.  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #>  9 dc        2021-12-31 295.  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #> 10 de        2021-12-31 150.  [0.05, 0.95]<q-rng> 2021-12-31    2022-01-07  #> # … with 46 more rows"},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Examples of Preprocessing and Models","text":"epipredict package utilizes tidymodels framework, namely recipes dplyr-like pipeable sequences feature engineering parsnip unified interface range models. epipredict additional customized feature engineering preprocessing steps, step_epi_shift(), step_population_scaling(), step_epi_naomit(). can used along steps recipes package feature engineering. vignette, illustrate examples use epipredict recipes parsnip different purposes epidemiology forecasting. focus simple basic autoregressive models, COVID cases deaths near future predicted using linear combination cases deaths near past. remaining vignette split three sections. first section, use Poisson regression predict death counts. second section, use linear regression predict death rates. Last least, create classification model hotspot predictions.","code":"library(tidyr) library(dplyr) library(epidatr) library(epiprocess) library(epipredict) library(recipes) library(parsnip) library(workflows) library(poissonreg)"},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"poisson-regression","dir":"Articles","previous_headings":"","what":"Poisson Regression","title":"Examples of Preprocessing and Models","text":"COVID-19, Center Disease Control Prevention (CDC) gathered models forecasts characterize state outbreak course. use inform public health decision makers potential consequences deploying control measures. One outcomes CDC forecasts death counts COVID-19. Although many state---art models, choose use Poisson regression, textbook example modeling count data, illustration using epipredict package existing tidymodel packages. case_death_counts_subset dataset comes epidatr package,contains number confirmed cases deaths June 4, 2021 Dec 31, 2021 U.S. states. wish predict 7-day ahead death counts lagged cases deaths. Furthermore, let state dummy variable. Using differential intercept coefficients, can allow intercept shift states. \\(\\mu_{t+7} = \\mathbb{E}(y_{t+7})\\), \\(y_{t+7}\\) assumed follow Poisson distribution mean \\(\\mu_{t+7}\\); \\(s_{\\text{state}}\\) dummy variables state take values either 0 1. Preprocessing steps performed using recipes functions get data ready modeling. diving , helpful understand roles recipes framework.","code":"x <- covidcast(   data_source = \"jhu-csse\",   signals = \"confirmed_incidence_num\",   time_type = \"day\",   geo_type = \"state\",   time_values = epirange(20210604, 20211231),   geo_values = \"ca,fl,tx,ny,nj\") %>%   fetch_tbl() %>%   select(geo_value, time_value, cases = value)  y <- covidcast(   data_source = \"jhu-csse\",   signals = \"deaths_incidence_num\",   time_type = \"day\",   geo_type = \"state\",   time_values = epirange(20210604, 20211231),   geo_values = \"ca,fl,tx,ny,nj\") %>%   fetch_tbl() %>%   select(geo_value, time_value, deaths = value)  case_death_counts_subset <- x %>%   full_join(y, by = c(\"geo_value\", \"time_value\")) %>%   as_epi_df()"},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"aside-on-recipes","dir":"Articles","previous_headings":"Poisson Regression","what":"Aside on recipes","title":"Examples of Preprocessing and Models","text":"recipes can assign one roles column data. roles restricted predefined set; can anything. conventional situations, typically “predictor” /“outcome”. Additional roles enable targeted step_*() operations specific variables groups variables. case, role predictor given explanatory variable go left-hand side model. role outcome response variable wish predict. geo_value time_value predefined roles unique epipredict package. Since work epi_df objects, datasets geo_value time_value passed automatically two roles assigned appropriate columns. recipes package also allows manual alterations roles bulk. couple handy functions can used together help us manipulate variable roles easily. update_role() alters existing role recipe assigns initial role variables yet declared role. add_role() adds additional role variables already role recipe, without overwriting old roles. remove_role() eliminates single existing role recipe.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"end-aside","dir":"Articles","previous_headings":"Poisson Regression","what":"End aside","title":"Examples of Preprocessing and Models","text":"Notice following preprocessing steps, used add_role() geo_value_factor since currently default role raw like dummified variables automatically predictor’s. specifying preprocessing steps, use parsnip package modeling getting prediction death count, 7 days latest available date dataset. Note time_value corresponds last available date training set, target date forecast (2022-01-07). Let’s take look fit: now, ’ve used Poisson regression model count data. Poisson regression can also used model rate data, case rates death rates, incorporating offset terms model. \\(\\text{log(population)}\\) log state population used scale count data left-hand side equation. several ways model rate data given count population data. First, parsnip framework, can specify formula fit(). However, lose ability use recipes framework create new variables since new variables exist original dataset lag leads called directly fit(). Alternatively, step_population_scaling() layer_population_scaling() epipredict package can perform population scaling provide population data, can model using models linear regression, illustrate next section.","code":"case_death_counts_subset <- case_death_counts_subset %>%   mutate(geo_value_factor = as.factor(geo_value)) %>%   as_epi_df()  epi_recipe(case_death_counts_subset) ## Recipe ##  ## Inputs: ##  ##        role #variables ##   geo_value          1 ##         raw          3 ##  time_value          1 r <- epi_recipe(case_death_counts_subset) %>%   add_role(geo_value_factor, new_role = \"predictor\") %>%   step_dummy(geo_value_factor) %>%   ## Occasionally, data reporting errors / corrections result in negative   ## cases / deaths   step_mutate(cases = pmax(cases, 0), deaths = pmax(deaths, 0)) %>%     step_epi_lag(cases, deaths, lag = c(0, 7)) %>%   step_epi_ahead(deaths, ahead = 7, role = \"outcome\") %>%   step_epi_naomit() latest <- get_test_data(r, case_death_counts_subset)  wf <- epi_workflow(r, parsnip::poisson_reg()) %>%        fit(case_death_counts_subset)  predict(wf, latest) %>% filter(!is.na(.pred)) ## An `epi_df` object, 5 x 3 with metadata: ## * geo_type  = state ## * time_type = day ## * as_of     = 2022-10-27 19:58:39 ##  ## # A tibble: 5 × 3 ##   geo_value time_value .pred ## * <chr>     <date>     <dbl> ## 1 ca        2021-12-31 109.  ## 2 fl        2021-12-31 270.  ## 3 nj        2021-12-31  22.5 ## 4 ny        2021-12-31  94.8 ## 5 tx        2021-12-31  90.8 extract_fit_engine(wf) ##  ## Call:  stats::glm(formula = ..y ~ ., family = stats::poisson, data = data) ##  ## Coefficients: ##         (Intercept)  geo_value_factor_fl  geo_value_factor_nj   ##           3.972e+00           -1.516e-01           -1.427e+00   ## geo_value_factor_ny  geo_value_factor_tx          lag_0_cases   ##          -6.885e-01            3.003e-01            1.338e-05   ##         lag_7_cases         lag_0_deaths         lag_7_deaths   ##           1.728e-06            1.734e-03            8.545e-04   ##  ## Degrees of Freedom: 984 Total (i.e. Null);  976 Residual ## Null Deviance:       140000  ## Residual Deviance: 58300     AIC: 62900"},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"linear-regression","dir":"Articles","previous_headings":"","what":"Linear Regression","title":"Examples of Preprocessing and Models","text":"COVID-19, CDC required submission case death count predictions. However, Delphi Group preferred train rate data instead, puts different locations similar scale. can use liner regression predict death rates use state population data scale rates counts. using layer_population_scaling() epipredict package. Additionally, forecasts submitted, prediction intervals provided along point estimates. can obtained via postprocessing layer_residual_quantiles(). Although worth pointing layer_residual_quantiles() used population scaling else transformation make results uninterpretable. wish predict 7-day ahead death counts lagged case rates death rates, along extra behaviour indicator inputs. Namely, use survey data COVID-19 Trends Impact Survey. survey data shows estimated percentage people wore mask time public past 7 days estimated percentage respondents reported people encountered public past 7 days maintained distance least 6 feet. State-wise population data 2019 U.S. Census included package used layer_population_scaling(). Rather using raw mask-wearing / social-distancing metrics, sake illustration, ’ll convert categorical predictors.  take subset death rate case rate data built-dataset case_death_rate_subset. Preprocessing steps rely functions epipredict package well recipes package: Additionally, also many functions recipes package allow scalar transformations, log transformations data centering. case, center numerical predictors allow meaningful interpretation intercept. sanity check can see training data look like directly predicting results, need add postprocessing layers obtain death counts instead death rates. Note rates used far “per 100K people” rather “per person”. columns marked *_scaled rescaled correct units, case deaths rather deaths per 100K people (remain .pred). look prediction intervals: Last least, let’s take look regression fit check coefficients:","code":"behav_ind_mask <- covidcast(   data_source = \"fb-survey\",   signals = \"smoothed_wwearing_mask_7d\",   time_type = \"day\",   geo_type = \"state\",   time_values = epirange(20210604, 20211231),   geo_values = \"ca,fl,tx,ny,nj\")  %>%   fetch_tbl() %>%   select(geo_value, time_value, masking = value)  behav_ind_distancing <- covidcast(   data_source = \"fb-survey\",   signals = \"smoothed_wothers_distanced_public\",   time_type = \"day\",   geo_type = \"state\",   time_values = epirange(20210604, 20211231),   geo_values = \"ca,fl,tx,ny,nj\")  %>%   fetch_tbl() %>%   select(geo_value, time_value, distancing = value)   pop_dat <- state_census %>% select(abbr, pop)  behav_ind <- behav_ind_mask %>%   full_join(behav_ind_distancing, by = c(\"geo_value\", \"time_value\")) jhu <- case_death_rate_subset %>%   dplyr::filter(     time_value >= \"2021-06-04\",      time_value <= \"2021-12-31\",     geo_value %in% c(\"ca\",\"fl\",\"tx\",\"ny\",\"nj\")) jhu <- jhu %>%   mutate(geo_value_factor = as.factor(geo_value)) %>%   left_join(behav_ind, by = c(\"geo_value\", \"time_value\")) %>%   as_epi_df()              r <- epi_recipe(jhu) %>%   add_role(geo_value_factor, new_role = \"predictor\") %>%   step_dummy(geo_value_factor) %>%   step_epi_lag(case_rate, death_rate, lag = c(0, 7, 14)) %>%   step_mutate(masking = cut_number(masking, 5),                distancing = cut_number(distancing, 5)) %>%   step_epi_ahead(death_rate, ahead = 7, role = \"outcome\") %>%   step_center(contains(\"lag\"), role = \"predictor\") %>%   step_epi_naomit() glimpse(slice_sample(bake(prep(r, jhu), jhu), n = 6)) ## Rows: 6 ## Columns: 17 ## $ time_value          <date> 2021-10-20, 2021-07-16, 2021-11-26, 2021-06-18, 2… ## $ geo_value           <chr> \"ny\", \"fl\", \"ny\", \"ny\", \"tx\", \"ca\" ## $ case_rate           <dbl> 23.106230, 29.874482, 34.855123, 1.959257, 33.5180… ## $ death_rate          <dbl> 0.1662266, 0.1518406, 0.1492345, 0.0554089, 0.9006… ## $ masking             <fct> \"(60.2,63.9]\", \"[42.7,52.8]\", \"(60.2,63.9]\", \"(60.… ## $ distancing          <fct> \"(21.1,27]\", \"[13.9,18.4]\", \"(19.8,21.1]\", \"(27,43… ## $ geo_value_factor_fl <int> 0, 1, 0, 0, 0, 0 ## $ geo_value_factor_nj <int> 0, 0, 0, 0, 0, 0 ## $ geo_value_factor_ny <int> 1, 0, 1, 1, 0, 0 ## $ geo_value_factor_tx <int> 0, 0, 0, 0, 1, 0 ## $ lag_0_case_rate     <dbl> -3.835432, 2.932819, 7.913461, -24.982405, 6.57635… ## $ lag_7_case_rate     <dbl> -2.948152, -11.332313, 4.933203, -24.007948, 11.77… ## $ lag_14_case_rate    <dbl> -2.0527447, -16.6322746, -0.7377079, -23.7235163, … ## $ lag_0_death_rate    <dbl> -0.1156470, -0.1300330, -0.1326391, -0.2264647, 0.… ## $ lag_7_death_rate    <dbl> -0.0742751, -0.1688148, -0.1089980, -0.2035624, 0.… ## $ lag_14_death_rate   <dbl> -0.0890508, -0.1418647, -0.0993938, -0.1651456, 0.… ## $ ahead_7_death_rate  <dbl> 0.1950392, 0.1853639, 0.2600522, 0.0347229, 0.5843… f <- frosting() %>%   layer_predict() %>%   layer_add_target_date(\"2022-01-07\") %>%    layer_threshold(.pred, lower = 0) %>%   layer_residual_quantiles(probs = c(0.05, 0.95), symmetrize = FALSE) %>%   layer_naomit(.pred) %>%   layer_population_scaling(     .pred, .pred_distn, df = pop_dat, rate_rescaling = 1e5,     by = c(\"geo_value\" = \"abbr\"), df_pop_col = \"pop\")  wf <- epi_workflow(r, parsnip::linear_reg()) %>%     fit(jhu) %>%     add_frosting(f)  latest <- get_test_data(recipe = r, x = jhu) p <- predict(wf, latest) p ## An `epi_df` object, 5 x 7 with metadata: ## * geo_type  = state ## * time_type = day ## * as_of     = 2022-05-31 19:08:25 ##  ## # A tibble: 5 × 7 ##   geo_value time_value .pred target_date         .pred_distn .pred_scaled ## * <chr>     <date>     <dbl> <date>                   <dist>        <dbl> ## 1 ca        2021-12-31 0.139 2022-01-07  [0.05, 0.95]<q-rng>         55.1 ## 2 fl        2021-12-31 0.280 2022-01-07  [0.05, 0.95]<q-rng>         60.2 ## 3 nj        2021-12-31 0.604 2022-01-07  [0.05, 0.95]<q-rng>         53.7 ## 4 ny        2021-12-31 0.647 2022-01-07  [0.05, 0.95]<q-rng>        126.  ## 5 tx        2021-12-31 0.291 2022-01-07  [0.05, 0.95]<q-rng>         84.3 ## # … with 1 more variable: .pred_distn_scaled <dist> p %>%   select(geo_value, target_date, .pred_scaled, .pred_distn_scaled) %>%   mutate(.pred_distn_scaled = nested_quantiles(.pred_distn_scaled)) %>%   unnest(.pred_distn_scaled) %>%   pivot_wider(names_from = tau, values_from = q) ## # A tibble: 5 × 5 ##   geo_value target_date .pred_scaled `0.05` `0.95` ##   <chr>     <date>             <dbl>  <dbl>  <dbl> ## 1 ca        2022-01-07          55.1   11.7   95.9 ## 2 fl        2022-01-07          60.2   36.6   82.4 ## 3 nj        2022-01-07          53.7   43.9   62.9 ## 4 ny        2022-01-07         126.   105.   146.  ## 5 tx        2022-01-07          84.3   52.4  114. ##  ## Call: ## stats::lm(formula = ..y ~ ., data = data) ##  ## Residuals: ##      Min       1Q   Median       3Q      Max  ## -0.47283 -0.03787 -0.00352  0.03817  0.52541  ##  ## Coefficients: ##                       Estimate Std. Error t value Pr(>|t|)     ## (Intercept)          0.3071695  0.0061168  50.217  < 2e-16 *** ## geo_value_factor_fl  0.0910478  0.0103484   8.798  < 2e-16 *** ## geo_value_factor_nj -0.0041691  0.0083468  -0.499  0.61756     ## geo_value_factor_ny -0.0233198  0.0083956  -2.778  0.00559 **  ## geo_value_factor_tx  0.0670642  0.0090774   7.388 3.29e-13 *** ## lag_0_case_rate     -0.0018135  0.0003516  -5.158 3.05e-07 *** ## lag_7_case_rate      0.0056094  0.0006935   8.089 1.85e-15 *** ## lag_14_case_rate     0.0042759  0.0006493   6.585 7.55e-11 *** ## lag_0_death_rate     0.2938690  0.0325400   9.031  < 2e-16 *** ## lag_7_death_rate     0.1322046  0.0318442   4.152 3.60e-05 *** ## lag_14_death_rate    0.0203192  0.0260436   0.780  0.43547     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Residual standard error: 0.08104 on 939 degrees of freedom ## Multiple R-squared:  0.9404, Adjusted R-squared:  0.9398  ## F-statistic:  1481 on 10 and 939 DF,  p-value: < 2.2e-16"},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"classification","dir":"Articles","previous_headings":"","what":"Classification","title":"Examples of Preprocessing and Models","text":"Sometimes preferable create predictive model surges upswings rather raw values. case, target predict future increased case rates(), decreased case rates (), flat case rates (flat) relative current level. model often referred hotspot prediction models. refer model notations McDonald, Bien, Green, Hu, et al. extend application predict three categories instead two. Hotspot prediction predicts categorical variable defined terms relative change \\(Y_{\\ell, t+}\\) compared \\(Y_{\\ell, t}\\). \\(Y_{\\ell, t}\\) denotes case rates location \\(\\ell\\) time \\(t\\). define response variables follows: \\[ Z_{\\ell, t}=     \\begin{cases}       \\text{}, & \\text{}\\ Y^{\\Delta}_{\\ell, t} > 0.25 \\\\       \\text{}, & \\text{}\\  Y^{\\Delta}_{\\ell, t} < -0.25\\\\       \\text{flat}, & \\text{otherwise}     \\end{cases} \\] \\(Y^{\\Delta}_{\\ell, t} = (Y_{\\ell, t}- Y_{\\ell, t-7})/(Y_{\\ell, t-7})\\). say location \\(\\ell\\) hotspot time \\(t\\) \\(Z_{\\ell,t}\\) categorized ‘’, meaning number newly reported cases past 7 days increased least 25% compared preceding week. \\(Z_{\\ell,t}\\) categorized ‘’, suggests least 25% decrease newly reported cases past 7 days. Otherwise, consider trends flat. expression multinomial regression model follows: \\[ \\pi_{j}(x) = \\text{Pr}(Y = j|x) = \\frac{e^{g_j(x)}}{\\sum_{k=0}^2 g_j(x) } \\] \\(j\\) either (Y=0), flat (Y=1), (Y=2), \\[g_0(x) = 0\\] Preprocessing steps similar previous models additional step categorizing response variables. take subset death rate case rate data built-dataset case_death_rate_subset. fit multinomial regression take look predictions: can also take look fit: One also use formula epi_recipe() achieve results . However, one add_formula(), add_recipe(), workflow_variables() must specified. purpose demonstrating add_formula rather add_recipe, prep bake recipe return data.frame used model fitting.","code":"jhu <- case_death_rate_subset %>%   dplyr::filter(time_value >= \"2021-06-04\",                  time_value <= \"2021-12-31\",   geo_value %in% c(\"ca\",\"fl\",\"tx\",\"ny\",\"nj\")) %>%   mutate(geo_value_factor = as.factor(geo_value)) %>%   as_epi_df()  r <- epi_recipe(jhu) %>%   add_role(time_value, new_role = \"predictor\") %>%   step_dummy(geo_value_factor) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(case_rate, ahead = 7, role = \"predictor\") %>%   step_mutate(     pct_diff_ahead = case_when(       lag_7_case_rate == 0 ~ 0,       TRUE ~ (ahead_7_case_rate - lag_0_case_rate) / lag_0_case_rate),     pct_diff_wk1 = case_when(       lag_7_case_rate == 0 ~ 0,        TRUE ~ (lag_0_case_rate - lag_7_case_rate) / lag_7_case_rate),     pct_diff_wk2 = case_when(       lag_14_case_rate == 0 ~ 0,       TRUE ~ (lag_7_case_rate - lag_14_case_rate) / lag_14_case_rate)) %>%   step_mutate(     response = case_when(       pct_diff_ahead < -0.20 ~ \"down\",       pct_diff_ahead > 0.25 ~ \"up\",       TRUE ~ \"flat\"),      role = \"outcome\") %>%    step_rm(death_rate, case_rate, lag_0_case_rate,  lag_7_case_rate,            lag_14_case_rate, ahead_7_case_rate, pct_diff_ahead) %>%   step_epi_naomit() wf <- epi_workflow(r, parsnip::multinom_reg()) %>%     fit(jhu)  latest <- get_test_data(recipe = r, x = jhu) predict(wf, latest) %>% filter(!is.na(.pred_class)) ## An `epi_df` object, 5 x 3 with metadata: ## * geo_type  = state ## * time_type = day ## * as_of     = 2022-05-31 19:08:25 ##  ## # A tibble: 5 × 3 ##   geo_value time_value .pred_class ## * <chr>     <date>     <fct>       ## 1 ca        2021-12-31 up          ## 2 fl        2021-12-31 up          ## 3 nj        2021-12-31 up          ## 4 ny        2021-12-31 up          ## 5 tx        2021-12-31 flat extract_fit_engine(wf) ## Call: ## nnet::multinom(formula = ..y ~ ., data = data, trace = FALSE) ##  ## Coefficients: ##      (Intercept)   time_value geo_value_factor_fl geo_value_factor_nj ## flat   -58.11177  0.003162471          -0.5978151            1.350320 ## up      46.45080 -0.002429847          -0.4682080            1.572085 ##      geo_value_factor_ny geo_value_factor_tx pct_diff_wk1 pct_diff_wk2 ## flat            3.113677          -0.3010305     1.263089     3.610543 ## up              3.172692          -0.2505232     2.194646     4.266267 ##  ## Residual Deviance: 1529.929  ## AIC: 1561.929 b <- bake(prep(r, jhu), jhu)  epi_workflow() %>%   add_formula(response ~ geo_value + pct_diff_wk1 + pct_diff_wk2) %>%   add_model(parsnip::multinom_reg()) %>%   fit(data = b) ## ══ Workflow [trained] ══════════════════════════════════════════════════════════ ## Preprocessor: Formula ## Model: multinom_reg() ##  ## ── Preprocessor ──────────────────────────────────────────────────────────────── ## response ~ geo_value + pct_diff_wk1 + pct_diff_wk2 ##  ## ── Model ─────────────────────────────────────────────────────────────────────── ## Call: ## nnet::multinom(formula = ..y ~ ., data = data, trace = FALSE) ##  ## Coefficients: ##      (Intercept) geo_valuefl geo_valuenj geo_valueny geo_valuetx pct_diff_wk1 ## flat   1.6571496  -0.6175111    1.329754    3.073078  -0.3075562     1.256555 ## up     0.5724124  -0.4165345    1.536337    3.118347  -0.2570642     2.098257 ##      pct_diff_wk2 ## flat     3.515819 ## up       4.326188 ##  ## Residual Deviance: 1548.994  ## AIC: 1576.994"},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"benefits-of-lagging-and-leading-in-epipredict","dir":"Articles","previous_headings":"","what":"Benefits of Lagging and Leading in epipredict","title":"Examples of Preprocessing and Models","text":"step_epi_ahead step_epi_lag functions epipredict package handy creating correct lags leads future predictions. Let’s start simple dataset preprocessing: want predict death rates 2022-01-07, 7 days ahead latest available date dataset. compare two methods trying create lags leads: Notice difference number rows b1 b2 returns. second version, one doesn’t use step_epi_ahead step_epi_lag, omitted dates compared one used epipredict functions. model trained without functions predicting 7 days ahead 2021-12-24 instead 7 days ahead 2021-12-31.","code":"ex <- case_death_rate_subset %>%   dplyr::filter(time_value >= \"2021-12-01\",                  time_value <= \"2021-12-31\",                 geo_value == \"ca\")  dim(ex) ## [1] 31  4 p1 <- epi_recipe(ex) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7, role = \"outcome\") %>%   step_epi_naomit() %>%   prep()  b1 <- bake(p1, ex) b1 ## # A tibble: 17 × 11 ##    time_value geo_value case_r…¹ death…² lag_0…³ lag_7…⁴ lag_1…⁵ lag_0…⁶ lag_7…⁷ ##    <date>     <chr>        <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> ##  1 2021-12-15 ca            15.8   0.157    15.8    18.0    12.5   0.157   0.183 ##  2 2021-12-16 ca            16.3   0.155    16.3    17.4    15.5   0.155   0.179 ##  3 2021-12-17 ca            16.9   0.158    16.9    17.4    16.0   0.158   0.164 ##  4 2021-12-18 ca            17.6   0.164    17.6    17.2    16.6   0.164   0.165 ##  5 2021-12-19 ca            19.1   0.165    19.1    16.3    16.7   0.165   0.167 ##  6 2021-12-20 ca            20.6   0.164    20.6    16.0    17.3   0.164   0.167 ##  7 2021-12-21 ca            22.6   0.165    22.6    16.6    16.9   0.165   0.169 ##  8 2021-12-22 ca            26.2   0.163    26.2    15.8    18.0   0.163   0.157 ##  9 2021-12-23 ca            30.8   0.167    30.8    16.3    17.4   0.167   0.155 ## 10 2021-12-24 ca            33.8   0.167    33.8    16.9    17.4   0.167   0.158 ## 11 2021-12-25 ca            32.6   0.153    32.6    17.6    17.2   0.153   0.164 ## 12 2021-12-26 ca            34.5   0.153    34.5    19.1    16.3   0.153   0.165 ## 13 2021-12-27 ca            48.4   0.132    48.4    20.6    16.0   0.132   0.164 ## 14 2021-12-28 ca            54.9   0.142    54.9    22.6    16.6   0.142   0.165 ## 15 2021-12-29 ca            63.7   0.140    63.7    26.2    15.8   0.140   0.163 ## 16 2021-12-30 ca            76.0   0.140    76.0    30.8    16.3   0.140   0.167 ## 17 2021-12-31 ca            84.4   0.142    84.4    33.8    16.9   0.142   0.167 ## # … with 2 more variables: lag_14_death_rate <dbl>, ahead_7_death_rate <dbl>, ## #   and abbreviated variable names ¹​case_rate, ²​death_rate, ³​lag_0_case_rate, ## #   ⁴​lag_7_case_rate, ⁵​lag_14_case_rate, ⁶​lag_0_death_rate, ⁷​lag_7_death_rate p2 <- epi_recipe(ex) %>%   step_mutate(lag0case_rate = lag(case_rate, 0),               lag7case_rate = lag(case_rate, 7),               lag14case_rate = lag(case_rate, 14),               lag0death_rate = lag(death_rate, 0),               lag7death_rate = lag(death_rate, 7),               lag14death_rate = lag(death_rate, 14),               ahead7death_rate = lead(death_rate, 7)) %>%   step_epi_naomit() %>%   prep()  b2 <- bake(p2, ex) b2 ## # A tibble: 10 × 11 ##    time_value geo_value case_r…¹ death…² lag0c…³ lag7c…⁴ lag14…⁵ lag0d…⁶ lag7d…⁷ ##    <date>     <chr>        <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> ##  1 2021-12-15 ca            15.8   0.157    15.8    18.0    12.5   0.157   0.183 ##  2 2021-12-16 ca            16.3   0.155    16.3    17.4    15.5   0.155   0.179 ##  3 2021-12-17 ca            16.9   0.158    16.9    17.4    16.0   0.158   0.164 ##  4 2021-12-18 ca            17.6   0.164    17.6    17.2    16.6   0.164   0.165 ##  5 2021-12-19 ca            19.1   0.165    19.1    16.3    16.7   0.165   0.167 ##  6 2021-12-20 ca            20.6   0.164    20.6    16.0    17.3   0.164   0.167 ##  7 2021-12-21 ca            22.6   0.165    22.6    16.6    16.9   0.165   0.169 ##  8 2021-12-22 ca            26.2   0.163    26.2    15.8    18.0   0.163   0.157 ##  9 2021-12-23 ca            30.8   0.167    30.8    16.3    17.4   0.167   0.155 ## 10 2021-12-24 ca            33.8   0.167    33.8    16.9    17.4   0.167   0.158 ## # … with 2 more variables: lag14death_rate <dbl>, ahead7death_rate <dbl>, and ## #   abbreviated variable names ¹​case_rate, ²​death_rate, ³​lag0case_rate, ## #   ⁴​lag7case_rate, ⁵​lag14case_rate, ⁶​lag0death_rate, ⁷​lag7death_rate dates_used_in_training1 <-  b1 %>% select(- ahead_7_death_rate) %>% na.omit() %>% select(time_value)  dates_used_in_training1 ## # A tibble: 17 × 1 ##    time_value ##    <date>     ##  1 2021-12-15 ##  2 2021-12-16 ##  3 2021-12-17 ##  4 2021-12-18 ##  5 2021-12-19 ##  6 2021-12-20 ##  7 2021-12-21 ##  8 2021-12-22 ##  9 2021-12-23 ## 10 2021-12-24 ## 11 2021-12-25 ## 12 2021-12-26 ## 13 2021-12-27 ## 14 2021-12-28 ## 15 2021-12-29 ## 16 2021-12-30 ## 17 2021-12-31 dates_used_in_training2 <-    b2 %>% select(- ahead7death_rate) %>% na.omit() %>% select(time_value)  dates_used_in_training2 ## # A tibble: 10 × 1 ##    time_value ##    <date>     ##  1 2021-12-15 ##  2 2021-12-16 ##  3 2021-12-17 ##  4 2021-12-18 ##  5 2021-12-19 ##  6 2021-12-20 ##  7 2021-12-21 ##  8 2021-12-22 ##  9 2021-12-23 ## 10 2021-12-24"},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Examples of Preprocessing and Models","text":"McDonald, Bien, Green, Hu, et al. “Can auxiliary indicators improve COVID-19 forecasting hotspot prediction?.” Proceedings National Academy Sciences 118.51 (2021): e2111453118. doi:10.1073/pnas.2111453118","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/preprocessing-and-models.html","id":"attribution","dir":"Articles","previous_headings":"","what":"Attribution","title":"Examples of Preprocessing and Models","text":"object contains modified part COVID-19 Data Repository Center Systems Science Engineering (CSSE) Johns Hopkins University republished COVIDcast Epidata API. data set licensed terms Creative Commons Attribution 4.0 International license Johns Hopkins University behalf Center Systems Science Engineering. Copyright Johns Hopkins University 2020.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/sliding.html","id":"demonstrations-of-sliding-ar-and-arx-forecasters","dir":"Articles","previous_headings":"","what":"Demonstrations of sliding AR and ARX forecasters","title":"Demonstrations of sliding AR and ARX forecasters","text":"key function epiprocess package epi_slide(), allows user apply function formula-based computation variables epi_df running window n time steps (see following epiprocess vignette go basics function: “Slide computation signal values”). equivalent sliding method epi_archive object can called using wrapper function epix_slide() (refer following vignette basicsof function: “Work archive objects data revisions”). key difference epi_slide() performs version-aware computations. , function uses data available time t reference time. vignette, use epi_slide() epix_slide() backtesting arx_forecaster historical COVID-19 case data US Canada. precisely, first demonstrate using epi_slide() slide ARX forecasters epi_df object compare results obtained using different forecasting engines. compare results version-aware unaware forecasting, former obtained applying epix_slide() epi_archive object, latter obtained applying epi_slide() latest snapshot data.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/articles/sliding.html","id":"example-using-cli-and-case-data-from-us-states","dir":"Articles","previous_headings":"Demonstrations of sliding AR and ARX forecasters > Comparing different forecasting engines","what":"Example using CLI and case data from US states","title":"Demonstrations of sliding AR and ARX forecasters","text":"First, download version history (ie. archive) percentage doctor’s visits CLI (COVID-like illness) computed medical insurance claims number new confirmed COVID-19 cases per 100,000 population (daily) 50 states COVIDcast API. process , modification use sync = locf epix_merge() last version observation can carried forward extrapolate unavailable versions less --date input archive. obtaining latest snapshot data, produce forecasts data using default engine simple linear regression compare random forest. Note warnings forecast date less recent update date data suppressed avoid cluttering output. , arx_forecaster() heavy lifting. creates leads target (respecting time stamps locations) along lags features (, response doctors visits), estimates forecasting model using specified engine, creates predictions, non-parametric confidence bands. tunable parameters. see predictions compare, plot top latest case rates. Note even though ’ve fitted states, ’ll just display results two states, California (CA) Florida (FL), get sense model performance keeping simple. feel free modify code look results states.  two states interest, simple linear regression clearly performs better random forest terms accuracy predictions result overconfident predictions (narrow confidence bands). Though, general, approaches perform great. behaviour rather different across states effects notable factors age public health measures may important account forecasting. Including factors well making enhancements correcting outliers improvements one make simple model future.","code":"theme_set(theme_bw())  y <- readRDS(system.file(\"extdata\", \"all_states_covidcast_signals.rds\",                           package = \"epipredict\", mustWork = TRUE))    y1 <- y[[1]] %>%    select(geo_value, time_value, version = issue, percent_cli = value) %>%   as_epi_archive()  x <- epix_merge(   y1,    y[[2]] %>%      select(geo_value, time_value, version = issue, case_rate = value) %>%     as_epi_archive(),    sync = \"locf\") # Latest snapshot of data, and forecast dates x_latest <- epix_as_of(x, max_version = max(x$versions_end))  fc_time_values <- seq(as.Date(\"2020-08-01\"), as.Date(\"2021-12-01\"),                        by = \"1 month\")  k_week_ahead <- function(epi_df, outcome, predictors, ahead = 7, engine) {   epi_df %>%     epi_slide(        ~arx_forecaster(         .x, outcome, predictors, engine,          args_list = arx_args_list(ahead = ahead)       ) %>%         extract2(\"predictions\") %>%          select(-c(geo_value, time_value)),        n = 120,        ref_time_values = fc_time_values,        new_col_name = \"fc\"     ) %>%      select(geo_value, time_value, starts_with(\"fc\")) %>%     mutate(engine_type = engine$engine) }  # Generate the forecasts, and bind them together fc <- bind_rows(   purrr::map_dfr(     c(7,14,21,28),      ~ k_week_ahead(x_latest, \"case_rate\", c(\"case_rate\", \"percent_cli\"), .x,                    engine = linear_reg())     ),   purrr::map_dfr(     c(7,14,21,28),      ~ k_week_ahead(x_latest, \"case_rate\", c(\"case_rate\", \"percent_cli\"), .x,                    engine = rand_forest(mode = \"regression\"))     )) %>%    mutate(.pred_distn = nested_quantiles(fc_.pred_distn)) %>% # \"nested\" list-col   unnest(.pred_distn) %>%    pivot_wider(names_from = tau, values_from = q) fc_cafl <- fc %>% filter(geo_value %in% c(\"ca\", \"fl\")) x_latest_cafl <- x_latest %>% filter(geo_value %in% c(\"ca\", \"fl\"))  ggplot(fc_cafl, aes(x = fc_target_date, group = time_value, fill = engine_type)) +    geom_line(data = x_latest_cafl, aes(x = time_value, y = case_rate),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = `0.05`, ymax = `0.95`), alpha = 0.4) +   geom_line(aes(y = fc_.pred)) +    geom_point(aes(y = fc_.pred), size = 0.5) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_grid(vars(geo_value), vars(engine_type), scales = \"free\") +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   scale_fill_brewer(palette = \"Set1\") +   labs(x = \"Date\", y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\")"},{"path":"https://cmu-delphi.github.io/epipredict/articles/sliding.html","id":"example-using-case-data-from-canada","dir":"Articles","previous_headings":"Demonstrations of sliding AR and ARX forecasters > Comparing different forecasting engines","what":"Example using case data from Canada","title":"Demonstrations of sliding AR and ARX forecasters","text":"leveraging flexibility epiprocess, can apply techniques data sources. Since collaborators British Columbia, Canada, ’ll essentially thing Canada . COVID-19 Canada Open Data Working Group collects daily time series data COVID-19 cases, deaths, recoveries, testing vaccinations health region province levels. Data collected publicly available sources government datasets news releases. Unfortunately, simple versioned source, created Commit history. First, load versioned case rates provincial level. converting 7-day averages (due highly variable provincial reporting mismatches), convert data epi_archive object, extract latest version . Finally, run forcasting exercise American data, compare forecasts produced using simple linear regression using boosted regression trees. figures shows results provinces.   approaches tend produce quite volatile forecasts (point predictions) /overly confident (narrow bands), particularly boosted regression trees used. meant simple demonstration sliding different engines arx_forecaster, may devote another vignette work improving predictive modelling using suite tools available epipredict.","code":"# source(\"drafts/canada-case-rates.R) can <- readRDS(   system.file(\"extdata\", \"can_prov_cases.rds\",                package = \"epipredict\", mustWork = TRUE)   ) %>%   group_by(version, geo_value) %>%    arrange(time_value) %>%    mutate(cr_7dav = RcppRoll::roll_meanr(case_rate, n = 7L)) #%>%   #filter(geo_value %in% c('Alberta', \"BC\")) can <- as_epi_archive(can) can_latest <- epix_as_of(can, max_version = max(can$DT$version))   # Generate the forecasts, and bind them together can_fc <- bind_rows(   purrr:::map_dfr(     c(7,14,21,28),      ~ k_week_ahead(can_latest, \"cr_7dav\", \"cr_7dav\", .x, linear_reg())   ),   purrr::map_dfr(     c(7,14,21,28),     ~ k_week_ahead(can_latest, \"cr_7dav\", \"cr_7dav\", .x,                     boost_tree(mode = \"regression\", trees = 20))   )) %>%    mutate(.pred_distn = nested_quantiles(fc_.pred_distn)) %>%    unnest(.pred_distn) %>%    pivot_wider(names_from = tau, values_from = q) ggplot(can_fc %>% filter(engine_type == \"lm\"),         aes(x = fc_target_date, group = time_value)) +   coord_cartesian(xlim = lubridate::ymd(c(\"2020-12-01\", NA))) +   geom_line(data = can_latest, aes(x = time_value, y = cr_7dav),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = `0.05`, ymax = `0.95`, fill = geo_value),               alpha = 0.4) +   geom_line(aes(y = fc_.pred)) + geom_point(aes(y = fc_.pred), size = 0.5) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_wrap(~geo_value, scales = \"free_y\", ncol = 3) +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(title = \"Using simple linear regression\", x = \"Date\",         y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\") ggplot(can_fc %>% filter(engine_type == \"xgboost\"),         aes(x = fc_target_date, group = time_value)) +   coord_cartesian(xlim = lubridate::ymd(c(\"2020-12-01\", NA))) +   geom_line(data = can_latest, aes(x = time_value, y = cr_7dav),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = `0.05`, ymax = `0.95`, fill = geo_value),               alpha = 0.4) +   geom_line(aes(y = fc_.pred)) + geom_point(aes(y = fc_.pred), size = 0.5) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_wrap(~ geo_value, scales = \"free_y\", ncol = 3) +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(title = \"Using boosted regression trees\", x = \"Date\",         y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\")"},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/articles/sliding.html","id":"example-using-case-data-from-us-states","dir":"Articles","previous_headings":"Demonstrations of sliding AR and ARX forecasters > Version-aware and unaware forecasting","what":"Example using case data from US states","title":"Demonstrations of sliding AR and ARX forecasters","text":"now employ forecaster uses properly-versioned data (available real-time) forecast future COVID-19 case rates current past COVID-19 case rates states. , can make forecasts archive, x, compare forecasts latest data, x_latest using general set-. version-aware forecasting, note x fed epix_slide(), version-unaware forecasting, x_latest fed epi_slide(). #%% update include percent_cli issue fixed? Now can plot results top latest case rates. , display focus results FL CA simplicity.  , observe results great two states, ’s likely due simplicity model (ex. omission key factors age public health measures) quality data (ex. personally corrected anomalies data). shall leave reader try version aware unaware forecasting exercise Canadian case rate data. code American state data readily adaptable purpose.","code":"k_week_ahead_as_of <- function(ahead = 7, version_aware = TRUE) {   if (version_aware) {     epix_slide(       x,       ~ arx_forecaster(.x, \"case_rate\", \"case_rate\",                        args_list = arx_args_list(ahead = ahead)) %>%         extract2(\"predictions\") %>%         select(-c(geo_value, time_value)),       n = 120,        ref_time_values = fc_time_values,        new_col_name = \"fc\") %>%        mutate(engine_type = \"lm\", version_aware = version_aware)   } else {     k_week_ahead(x_latest, \"case_rate\", \"case_rate\", ahead, linear_reg()) %>%       mutate(version_aware = version_aware)   } }  # Generate the forecasts, and bind them together fc <- bind_rows(   purrr::map_dfr(c(7,14,21,28), ~ k_week_ahead_as_of(.x, TRUE)),   purrr::map_dfr(c(7,14,21,28), ~ k_week_ahead_as_of(.x, FALSE))   ) %>%    mutate(.pred_distn = nested_quantiles(fc_.pred_distn)) %>%    unnest(.pred_distn) %>%    pivot_wider(names_from = tau, values_from = q) fc_cafl = fc %>% filter(geo_value %in% c(\"ca\", \"fl\")) x_latest_cafl = x_latest %>% filter(geo_value %in% c(\"ca\", \"fl\"))  ggplot(fc_cafl, aes(x = fc_target_date, group = time_value, fill = version_aware)) +   geom_line(data = x_latest_cafl, aes(x = time_value, y = case_rate),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = `0.05`, ymax = `0.95`), alpha = 0.4) +   geom_line(aes(y = fc_.pred)) + geom_point(aes(y = fc_.pred), size = 0.5) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_grid(geo_value ~ version_aware, scales = \"free\",               labeller = labeller(version_aware = label_both)) +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(x = \"Date\", y = \"Reported COVID-19 case rates\") +   scale_fill_brewer(palette = \"Set1\") +   theme(legend.position = \"none\")"},{"path":"https://cmu-delphi.github.io/epipredict/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel McDonald. Author, maintainer. Ryan Tibshirani. Author. Logan Brooks. Author. Rachel Lobay. Author. Maggie Liu. Author. Ken Mawer. Author. Chloe . Author. Jacob Bien. Contributor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"McDonald D, Tibshirani R, Brooks L, Lobay R, Liu M, Mawer K, C (2022). epipredict: Basic epidemiology forecasting methods. https://github.com/cmu-delphi/epipredict/, https://cmu-delphi.github.io/epipredict.","code":"@Manual{,   title = {epipredict: Basic epidemiology forecasting methods},   author = {Daniel McDonald and Ryan Tibshirani and Logan Brooks and Rachel Lobay and Maggie Liu and Ken Mawer and Chloe You},   year = {2022},   note = {https://github.com/cmu-delphi/epipredict/, https://cmu-delphi.github.io/epipredict}, }"},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"epipredict","dir":"","previous_headings":"","what":"Basic epidemiology forecasting methods","title":"Basic epidemiology forecasting methods","text":"Note: package currently development likely work expected.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Basic epidemiology forecasting methods","text":"can install development version epipredict GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"cmu-delphi/epipredict\")"},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Basic epidemiology forecasting methods","text":"can view documentation main branch https://cmu-delphi.github.io/epipredict.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"goals-for-epipredict","dir":"","previous_headings":"","what":"Goals for epipredict","title":"Basic epidemiology forecasting methods","text":"hope provide: Baseline flat-line forecaster Autoregressive forecaster Autoregressive classifier Preprocessor: things data model training Trainer: train model data, resulting fitted model object Predictor: make predictions, using fitted model object Postprocessor: things predictions returning Target audience: Basic. data, calls forecaster default arguments. Intermediate. Wants examine changes arguments, take advantage built flexibility. Advanced. Wants write forecasters. Maybe willing build components write. Advanced user find task relatively easy (’ll show ). Example: quiet period, user decides want first predict whether surge occur, say using variant information GISAID. surging locations, want train AR model using past surges location. Everywhere else, predict flat line. able lines code. Delphi’s forecasts produced/evaluated way now, code base scattered evolving. want consolidate, generalize, simplify allow others benefit well. basic framework allow something like following. feel familiar anyone working R+tidyverse. Simple linear autoregressive model scaling (modular) run epi_df one line. hypothetical example first classifying, fitting different models also fit framework. isn’t far current production models.","code":"my_fcaster = new_epi_predictor() %>%   add_preprocessor(scaler, var = cases, by = pop) %>%   add_preprocessor(lagger, var = dv_cli, lags = c(0, 7, 14)) %>%   add_trainer(lm) %>%   add_predictor(lm.predict) %>%   add_postprocessor(scaler, by = 1/pop) my_fcaster(lead(cases, 7) ~ ., epi_df, key_vars, time_vars)"},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"why-doesnt-this-exist","dir":"","previous_headings":"Goals for epipredict","what":"Why doesn’t this exist","title":"Basic epidemiology forecasting methods","text":"Closest neighbor {fable}. want major downsides: Small modifications hard (e.g. can’t “just use” glmnet instead lm) AR model. “iterative” forecasting, bad epidemiology. Much better simple models use “direct” forecasting. epi tasks, dramatically -cover. Layering possible/natural Can’t use methods aren’t already implemented. forecasts can’t produced fable. However: developers behind fable wrote package called fabletools powers model creation (based R6). can almost certainly borrow technology lever .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"what-this-isnt","dir":"","previous_headings":"Goals for epipredict","what":"What this isn’t","title":"Basic epidemiology forecasting methods","text":"framework SIR models. intend create simple versions, advanced models—use variants, hospitalizations, different types immunity, age stratification, etc.—compartmentalized way (though see pypm). types models also better scenario modeling short term forecasts unless quite complicated.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Add an epi_recipe to a workflow — add_epi_recipe","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"Add epi_recipe workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"","code":"add_epi_recipe(x, recipe, ..., blueprint = default_epi_recipe_blueprint())"},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"x workflow epi_workflow recipe recipe created using recipes::recipe() ... used. blueprint hardhat blueprint used fine tuning preprocessing. default_epi_recipe_blueprint() used. Note preprocessing done separate preprocessing might done automatically underlying model.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"x, updated new recipe preprocessor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"behaviour workflows::add_recipe() sets different default blueprint automatically handle epiprocess::epi_df data.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"","code":"library(epiprocess) library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(recipes) #>  #> Attaching package: ‘recipes’ #> The following object is masked from ‘package:stats’: #>  #>     step  jhu <- case_death_rate_subset %>%   filter(time_value > \"2021-08-01\") %>%   dplyr::arrange(geo_value, time_value)  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE)  workflow <- epi_workflow() %>%   add_epi_recipe(r)  workflow #> ══ Epi Workflow ════════════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: None #> Postprocessor: None #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 5 Recipe Steps #>  #> • step_epi_lag() #> • step_epi_ahead() #> • step_epi_lag() #> • step_naomit() #> • step_naomit()"},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Add frosting to a workflow — add_frosting","title":"Add frosting to a workflow — add_frosting","text":"Add frosting workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add frosting to a workflow — add_frosting","text":"","code":"add_frosting(x, frosting, ...)  remove_frosting(x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add frosting to a workflow — add_frosting","text":"x workflow frosting frosting layer created using frosting() ... used.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_frosting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add frosting to a workflow — add_frosting","text":"x, updated new removed frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_frosting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add frosting to a workflow — add_frosting","text":"","code":"library(dplyr) library(recipes)  jhu <- case_death_rate_subset %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE) wf <- epi_workflow(r, parsnip::linear_reg()) %>% parsnip::fit(jhu) latest <- jhu %>%   filter(time_value >= max(time_value) - 14)  # Add frosting to a workflow and predict f <- frosting() %>% layer_predict() %>% layer_naomit(.pred) wf1 <- wf %>% add_frosting(f) p1 <- predict(wf1, latest) p1 #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 3 #>   geo_value time_value .pred #> * <chr>     <date>     <dbl> #> 1 ak        2021-12-31 0.245 #> 2 ca        2021-12-31 0.313 #> 3 ny        2021-12-31 0.295  # Remove frosting from the workflow and predict wf2 <- wf1 %>% remove_frosting() p2 <- predict(wf2, latest) p2 #> An `epi_df` object, 108 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 108 × 3 #>    geo_value time_value .pred #>    <chr>     <date>     <dbl> #>  1 ak        2021-12-10    NA #>  2 ca        2021-12-10    NA #>  3 ny        2021-12-10    NA #>  4 ak        2021-12-11    NA #>  5 ca        2021-12-11    NA #>  6 ny        2021-12-11    NA #>  7 ak        2021-12-12    NA #>  8 ca        2021-12-12    NA #>  9 ny        2021-12-12    NA #> 10 ak        2021-12-13    NA #> # … with 98 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Add layer to a frosting object — add_layer","title":"Add layer to a frosting object — add_layer","text":"Add layer frosting object","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add layer to a frosting object — add_layer","text":"","code":"add_layer(frosting, object, flag = TRUE)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add layer to a frosting object — add_layer","text":"frosting frosting postprocessor object frosting layer flag logical determine layer added. Default TRUE.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add layer to a frosting object — add_layer","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/apply_frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply postprocessing to a fitted workflow — apply_frosting","title":"Apply postprocessing to a fitted workflow — apply_frosting","text":"function intended internal use. implements postprocessing inside predict() method fitted workflow.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/apply_frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply postprocessing to a fitted workflow — apply_frosting","text":"","code":"apply_frosting(workflow, ...)  # S3 method for default apply_frosting(workflow, components, ...)  # S3 method for epi_workflow apply_frosting(workflow, components, the_fit, the_recipe, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/apply_frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply postprocessing to a fitted workflow — apply_frosting","text":"workflow object class workflow ... additional arguments passed methods components list components containing model information. updated returned layer. mold - output calling hardhat::mold() workflow. contains information preprocessing, including recipe. forged - output calling hardhat::forge() workflow. predictors outcomes new_data. three components predictors, outcomes (new_data), extras (usually rest data, including keys). keys - put keys (time_value, geo_value, others) ease. the_fit fitted model object returned calling parsnip::fit() the_recipe epi_recipe preprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"ARX forecaster argument constructor — arx_args_list","title":"ARX forecaster argument constructor — arx_args_list","text":"Constructs list arguments arx_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ARX forecaster argument constructor — arx_args_list","text":"","code":"arx_args_list(   lags = c(0L, 7L, 14L),   ahead = 7L,   min_train_window = 20L,   forecast_date = NULL,   target_date = NULL,   levels = c(0.05, 0.95),   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = character(0L) )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ARX forecaster argument constructor — arx_args_list","text":"lags Vector List. Positive integers enumerating lags use autoregressive-type models (days). ahead Integer. Number time steps ahead (days) forecast date forecasts produced. min_train_window Integer. minimal amount training data (time unit epi_df) needed produce forecast. smaller, forecaster return NA predictions. forecast_date Date. date forecast created. default NULL attempt determine automatically. target_date Date. date forecast intended. default NULL attempt determine automatically. levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . symmetrize Logical. default TRUE calculates symmetric prediction intervals. nonneg Logical. default TRUE enforces nonnegative predictions hard-thresholding 0. quantile_by_key Character vector. Groups residuals listed keys calculating residual quantiles. See by_key argument layer_residual_quantiles() information. default, character(0) performs grouping.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ARX forecaster argument constructor — arx_args_list","text":"list containing updated parameter choices.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ARX forecaster argument constructor — arx_args_list","text":"","code":"arx_args_list() #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 20 #>  #> $levels #> [1] 0.05 0.95 #>  #> $forecast_date #> NULL #>  #> $target_date #> NULL #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  #> $quantile_by_key #> character(0) #>  arx_args_list(symmetrize = FALSE) #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 20 #>  #> $levels #> [1] 0.05 0.95 #>  #> $forecast_date #> NULL #>  #> $target_date #> NULL #>  #> $symmetrize #> [1] FALSE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  #> $quantile_by_key #> character(0) #>  arx_args_list(levels = c(.1, .3, .7, .9), min_train_window = 120) #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 120 #>  #> $levels #> [1] 0.1 0.3 0.7 0.9 #>  #> $forecast_date #> NULL #>  #> $target_date #> NULL #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  #> $quantile_by_key #> character(0) #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Direct autoregressive forecaster with covariates — arx_forecaster","title":"Direct autoregressive forecaster with covariates — arx_forecaster","text":"autoregressive forecasting model epiprocess::epi_df data. \"direct\" forecasting, meaning estimates model particular target horizon.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Direct autoregressive forecaster with covariates — arx_forecaster","text":"","code":"arx_forecaster(   epi_data,   outcome,   predictors,   trainer = parsnip::linear_reg(),   args_list = arx_args_list() )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Direct autoregressive forecaster with covariates — arx_forecaster","text":"epi_data epi_df object outcome character (scalar) specifying outcome (epi_df). predictors character vector giving column(s) predictor variables. trainer {parsnip} model describing type estimation. now, enforce mode = \"regression\". args_list list customization arguments determine type forecasting model. See arx_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Direct autoregressive forecaster with covariates — arx_forecaster","text":"list (1) predictions epi_df predicted values (2) epi_workflow, list encapsulates entire estimation workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Direct autoregressive forecaster with covariates — arx_forecaster","text":"","code":"jhu <- case_death_rate_subset %>%   dplyr::filter(time_value >= as.Date(\"2021-12-01\"))  out <- arx_forecaster(jhu, \"death_rate\",   c(\"case_rate\", \"death_rate\")) #> Warning: The forecast_date is less than the most recent update date of the data.forecast_date = 2021-12-31 while data is from 2022-05-31."},{"path":"https://cmu-delphi.github.io/epipredict/reference/augment.epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment data with predictions — augment.epi_workflow","title":"Augment data with predictions — augment.epi_workflow","text":"Augment data predictions","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/augment.epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment data with predictions — augment.epi_workflow","text":"","code":"# S3 method for epi_workflow augment(x, new_data, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/augment.epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment data with predictions — augment.epi_workflow","text":"x trained epi_workflow new_data epi_df predictors ... Arguments passed predict method.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/augment.epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment data with predictions — augment.epi_workflow","text":"new_data additional columns containing predicted values","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/bake.html","id":null,"dir":"Reference","previous_headings":"","what":"Bake an epi_recipe — bake.epi_recipe","title":"Bake an epi_recipe — bake.epi_recipe","text":"Bake epi_recipe","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/bake.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bake an epi_recipe — bake.epi_recipe","text":"","code":"# S3 method for epi_recipe bake(object, new_data, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/bake.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bake an epi_recipe — bake.epi_recipe","text":"object trained object recipe() least one preprocessing operation. new_data epi_df, data frame tibble preprocessing applied. NULL given new_data, pre-processed training data returned. ... One selector functions choose variables returned function. See recipes details. selectors given, default use everything().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/bake.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bake an epi_recipe — bake.epi_recipe","text":"epi_df may different columns original columns new_data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset of JHU daily state cases and deaths — case_death_rate_subset","title":"Subset of JHU daily state cases and deaths — case_death_rate_subset","text":"data source confirmed COVID-19 cases deaths based reports made available Center Systems Science Engineering Johns Hopkins University. example data ranges Dec 31, 2020 Dec 31, 2021, includes states.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset of JHU daily state cases and deaths — case_death_rate_subset","text":"","code":"case_death_rate_subset"},{"path":"https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Subset of JHU daily state cases and deaths — case_death_rate_subset","text":"tibble 20,496 rows 4 variables: geo_value geographic value associated row measurements. time_value time value associated row measurements. case_rate 7-day average signal number new confirmed COVID-19 cases per 100,000 population, daily death_rate 7-day average signal number new confirmed deaths due COVID-19 per 100,000 population, daily","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Subset of JHU daily state cases and deaths — case_death_rate_subset","text":"object contains modified part COVID-19 Data Repository Center Systems Science Engineering (CSSE) Johns Hopkins University republished COVIDcast Epidata API. data set licensed terms Creative Commons Attribution 4.0 International license Johns Hopkins University behalf Center Systems Science Engineering. Copyright Johns Hopkins University 2020. Modifications: COVIDcast Epidata API: signals taken directly JHU CSSE COVID-19 GitHub repository without changes. 7-day average signals computed Delphi calculating moving averages preceding 7 days, signal June 7 average underlying data June 1 7, inclusive.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/check_pname.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that newly created variable names don't overlap — check_pname","title":"Check that newly created variable names don't overlap — check_pname","text":"check_pname used slather method ensure newly created variable names overlap existing names. Throws warning check fails, creates random string.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/check_pname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that newly created variable names don't overlap — check_pname","text":"","code":"check_pname(res, preds, object, newname = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/check_pname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that newly created variable names don't overlap — check_pname","text":"res data frame tibble newly created variables. preds epi_df tibble containing predictions. object layer object passed slather(). newname string variable names object contain $name element","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new layer — create_layer","title":"Create a new layer — create_layer","text":"function creates skeleton new frosting layer. called inside package, create R script R/ directory, fill name layer, open file.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new layer — create_layer","text":"","code":"create_layer(name = NULL, open = rlang::is_interactive())"},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new layer — create_layer","text":"name Either name without extension, NULL create paired file based currently open file script editor. R/ file open, use_test() create/open corresponding test file; test file open, use_r() create/open corresponding R/ file. open Whether open file interactive editing.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_layer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new layer — create_layer","text":"","code":"if (FALSE) {    # Note: running this will write `layer_strawberry.R` to   # the `R/` directory of your current project   create_layer(\"strawberry\") }"},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiply columns of a data.frame by a matrix — df_mat_mul","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"Multiply columns data.frame matrix","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"","code":"df_mat_mul(dat, mat, out_names = \"out\", ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"dat data.frame mat matrix out_names Character vector. Creates names resulting columns multiplication. scalar, treated prefix remaining columns numbered sequentially. ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"data.frame new columns right. Original columns removed.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"","code":"df <- data.frame(matrix(1:200, ncol = 10)) mat <- matrix(1:10, ncol = 2) df_mat_mul(df, mat, \"z\", dplyr::num_range(\"X\", 2:6)) #>    X1  X7  X8  X9 X10   z1   z2 #> 1   1 121 141 161 181 1115 2640 #> 2   2 122 142 162 182 1130 2680 #> 3   3 123 143 163 183 1145 2720 #> 4   4 124 144 164 184 1160 2760 #> 5   5 125 145 165 185 1175 2800 #> 6   6 126 146 166 186 1190 2840 #> 7   7 127 147 167 187 1205 2880 #> 8   8 128 148 168 188 1220 2920 #> 9   9 129 149 169 189 1235 2960 #> 10 10 130 150 170 190 1250 3000 #> 11 11 131 151 171 191 1265 3040 #> 12 12 132 152 172 192 1280 3080 #> 13 13 133 153 173 193 1295 3120 #> 14 14 134 154 174 194 1310 3160 #> 15 15 135 155 175 195 1325 3200 #> 16 16 136 156 176 196 1340 3240 #> 17 17 137 157 177 197 1355 3280 #> 18 18 138 158 178 198 1370 3320 #> 19 19 139 159 179 199 1385 3360 #> 20 20 140 160 180 200 1400 3400"},{"path":"https://cmu-delphi.github.io/epipredict/reference/dist_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"A distribution parameterized by a set of quantiles — dist_quantiles","title":"A distribution parameterized by a set of quantiles — dist_quantiles","text":"distribution parameterized set quantiles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/dist_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A distribution parameterized by a set of quantiles — dist_quantiles","text":"","code":"dist_quantiles(x, tau)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/dist_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A distribution parameterized by a set of quantiles — dist_quantiles","text":"x vector values tau vector probabilities corresponding x","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/dist_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A distribution parameterized by a set of quantiles — dist_quantiles","text":"","code":"dstn <- dist_quantiles(list(1:4, 8:11), list(c(.2,.4,.6,.8))) quantile(dstn, p = c(.1, .25, .5, .9)) #> [[1]] #> [1] 0.124961 1.250000 2.500000 4.875039 #>  #> [[2]] #> [1]  7.124961  8.250000  9.500000 11.875039 #>  median(dstn) #> [1] 2.5 9.5  # it's a bit annoying to inspect the data vctrs::vec_data(vctrs::vec_data(dstn[1])[[1]]) #>   q tau #> 1 1 0.2 #> 2 2 0.4 #> 3 3 0.6 #> 4 4 0.8"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_juice.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract transformed training set — epi_juice","title":"Extract transformed training set — epi_juice","text":"Extract transformed training set","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_juice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract transformed training set — epi_juice","text":"","code":"epi_juice(object, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_juice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract transformed training set — epi_juice","text":"object trained object recipe() least one preprocessing operation. ... One selector functions choose variables returned function. See recipes details. selectors given, default use everything().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Grab any keys associated to an epi_df — epi_keys","title":"Grab any keys associated to an epi_df — epi_keys","text":"Grab keys associated epi_df","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grab any keys associated to an epi_df — epi_keys","text":"","code":"epi_keys(x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grab any keys associated to an epi_df — epi_keys","text":"x data.frame, tibble, epi_df","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grab any keys associated to an epi_df — epi_keys","text":"epi_df, returns \"keys\". Otherwise NULL","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a epi_recipe for preprocessing data — epi_recipe","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"recipe description steps applied data set order prepare data analysis. loose wrapper around recipes::recipe() properly handle additional columns present epi_df","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"","code":"epi_recipe(x, ...)  # S3 method for default epi_recipe(x, ...)  # S3 method for epi_df epi_recipe(x, formula = NULL, ..., vars = NULL, roles = NULL)  # S3 method for formula epi_recipe(formula, data, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"x, data data frame, tibble, epi_df template data set (see ). always coerced first row avoid memory issues ... arguments passed methods (currently used). formula model formula. -line functions used (e.g. log(x), x:y, etc.) minus signs allowed. types transformations enacted using step functions package. Dots allowed simple multivariate outcome terms (.e. need cbind; see Examples). vars character string column names corresponding variables used context (see ) roles character string (length vars) describes single role variable take. value anything common roles \"outcome\", \"predictor\", \"time_value\", \"geo_value\"","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"object class recipe sub-objects: var_info tibble containing information original data set columns term_info tibble contains current set terms data set. initially defaults data contained var_info. steps list step  check objects define sequence preprocessing operations applied data. default value NULL template tibble data. initialized data given data argument can different recipe trained.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"","code":"library(epiprocess) library(dplyr) library(recipes)  jhu <- case_death_rate_subset %>%   dplyr::filter(time_value > \"2021-08-01\") %>%   dplyr::arrange(geo_value, time_value)  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_naomit(all_predictors()) %>%   # below, `skip` means we don't do this at predict time   step_naomit(all_outcomes(), skip = TRUE)  r #> Recipe #>  #> Inputs: #>  #>        role #variables #>   geo_value          1 #>         raw          2 #>  time_value          1 #>  #> Operations: #>  #> Lagging death_rate by 0, 7, 14 #> Leading death_rate by 7 #> Lagging case_rate by 0, 7, 14 #> Removing rows with NA values in all_predictors() #> Removing rows with NA values in all_outcomes()"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","title":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","text":"lower-level function. performs error checking.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","text":"","code":"epi_shift(x, shifts, time_value, keys = NULL, out_name = \"x\")"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","text":"x Data frame. Variables shift shifts List. list element vector shifts. Negative values produce leads. list length number columns x. time_value Vector. length x giving time stamps. keys Data frame, vector, NULL. Additional grouping vars. out_name Chr. output list use prefix.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","text":"list tibbles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an epi_workflow — epi_workflow","title":"Create an epi_workflow — epi_workflow","text":"container object unifies preprocessing, fitting, prediction, postprocessing predictive modeling epidemiological data. extends functionality workflows::workflow() handle typical panel data structures found field. extension handled completely internally, invisible user. intents purposes, operates exactly like workflows::workflow(). details numerous examples, see .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an epi_workflow — epi_workflow","text":"","code":"epi_workflow(preprocessor = NULL, spec = NULL, postprocessor = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an epi_workflow — epi_workflow","text":"preprocessor optional preprocessor add workflow. One : formula, passed add_formula(). recipe, passed add_recipe(). workflow_variables() object, passed add_variables(). spec optional parsnip model specification add workflow. Passed add_model(). postprocessor optional postprocessor add workflow. Currently frosting allowed using, add_frosting().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an epi_workflow — epi_workflow","text":"new epi_workflow object.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an epi_workflow — epi_workflow","text":"","code":"library(dplyr) library(parsnip) library(recipes)  jhu <- case_death_rate_subset  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE)  wf <- epi_workflow(r, linear_reg())  wf #> ══ Epi Workflow ════════════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 5 Recipe Steps #>  #> • step_epi_lag() #> • step_epi_ahead() #> • step_epi_lag() #> • step_naomit() #> • step_naomit() #>  #> ── Model ─────────────────────────────────────────────────────────────────────── #> Linear Regression Model Specification (regression) #>  #> Computational engine: lm  #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_argument.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract an argument made to a frosting layer or recipe step — extract_argument","title":"Extract an argument made to a frosting layer or recipe step — extract_argument","text":"Extract argument made frosting layer recipe step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_argument.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract an argument made to a frosting layer or recipe step — extract_argument","text":"","code":"extract_argument(x, name, arg, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_argument.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract an argument made to a frosting layer or recipe step — extract_argument","text":"x epi_workflow, epi_recipe, frosting, step, layer object name name layer arg name argument ... used","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_argument.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract an argument made to a frosting layer or recipe step — extract_argument","text":"object originally passed argument layer step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_argument.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract an argument made to a frosting layer or recipe step — extract_argument","text":"","code":"f <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles(probs = c(0.0275, 0.975), symmetrize = FALSE) %>%   layer_naomit(.pred)  extract_argument(f, \"layer_residual_quantiles\", \"symmetrize\") #> [1] FALSE"},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the frosting object from a workflow — extract_frosting","title":"Extract the frosting object from a workflow — extract_frosting","text":"Extract frosting object workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the frosting object from a workflow — extract_frosting","text":"","code":"extract_frosting(x, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the frosting object from a workflow — extract_frosting","text":"x epi_workflow object ... used","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extract_frosting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the frosting object from a workflow — extract_frosting","text":"frosting object","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extrapolate_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize a distribution with a set of quantiles — extrapolate_quantiles","title":"Summarize a distribution with a set of quantiles — extrapolate_quantiles","text":"Summarize distribution set quantiles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extrapolate_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize a distribution with a set of quantiles — extrapolate_quantiles","text":"","code":"extrapolate_quantiles(x, p, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/extrapolate_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize a distribution with a set of quantiles — extrapolate_quantiles","text":"x distribution vector p vector probabilities calculate quantiles ... additional arguments passed quantile method","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extrapolate_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize a distribution with a set of quantiles — extrapolate_quantiles","text":"distribution vector containing dist_quantiles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/extrapolate_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize a distribution with a set of quantiles — extrapolate_quantiles","text":"","code":"library(distributional) dstn <- dist_normal(c(10, 2), c(5, 10)) extrapolate_quantiles(dstn, p = c(.25, 0.5, .75)) #> <distribution[2]> #> [1] [0.25, 0.75]<q-rng> [0.25, 0.75]<q-rng>  dstn <- dist_quantiles(list(1:4, 8:11), list(c(.2,.4,.6,.8))) # because this distribution is already quantiles, any extra quantiles are # appended extrapolate_quantiles(dstn, p = c(.25, 0.5, .75)) #> <distribution[2]> #> [1] [0.2, 0.8]<q-rng> [0.2, 0.8]<q-rng>  dstn <- c(dist_normal(c(10, 2), c(5, 10)),   dist_quantiles(list(1:4, 8:11), list(c(.2,.4,.6,.8)))) extrapolate_quantiles(dstn, p = c(.25, 0.5, .75)) #> <distribution[4]> #> [1] [0.25, 0.75]<q-rng> [0.25, 0.75]<q-rng> [0.2, 0.8]<q-rng>   #> [4] [0.2, 0.8]<q-rng>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline.html","id":null,"dir":"Reference","previous_headings":"","what":"(Internal) implementation of the flatline forecaster — flatline","title":"(Internal) implementation of the flatline forecaster — flatline","text":"internal function used create parsnip::linear_reg() model. somewhat odd behaviour (see ).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"(Internal) implementation of the flatline forecaster — flatline","text":"","code":"flatline(formula, data)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"(Internal) implementation of the flatline forecaster — flatline","text":"formula lhs single variable. standard usage, actually observed time series shifted forward forecast horizon. right hand side must contain keys (locations) panel data separated plus. observed time series must come last. example   Note function shifting, done outside. data data frame containing least variables used formula. must also contain column time_value giving observed time points.","code":"form <- as.formula(lead7_y ~ state + age + y)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"(Internal) implementation of the flatline forecaster — flatline","text":"S3 object class flatline two components: residuals - tibble keys .resid column contains forecast errors. .pred - tibble keys .pred column containing predictions future data (last observed outcome combination keys.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"(Internal) implementation of the flatline forecaster — flatline","text":"","code":"tib <- data.frame(y = runif(100),   expand.grid(k = letters[1:4], j = letters[5:9], time_value = 1:5)) %>%   dplyr::group_by(k, j) %>%   dplyr::mutate(y2 = dplyr::lead(y, 2)) # predict 2 steps ahead flat <- flatline(y2 ~ j + k + y, tib) # predictions for 20 locations sum(!is.na(flat$residuals$.resid)) # 100 residuals, but 40 are NA #> [1] 60"},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Flatline forecaster argument constructor — flatline_args_list","title":"Flatline forecaster argument constructor — flatline_args_list","text":"Constructs list arguments flatline_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flatline forecaster argument constructor — flatline_args_list","text":"","code":"flatline_args_list(   ahead = 7L,   min_train_window = 20L,   forecast_date = NULL,   target_date = NULL,   levels = c(0.05, 0.95),   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = character(0L) )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flatline forecaster argument constructor — flatline_args_list","text":"ahead Integer. Number time steps ahead (days) forecast date forecasts produced. min_train_window Integer. minimal amount training data (time unit epi_df) needed produce forecast. smaller, forecaster return NA predictions. forecast_date Date. date forecast created. default NULL attempt determine automatically. target_date Date. date forecast intended. default NULL attempt determine automatically. levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . symmetrize Logical. default TRUE calculates symmetric prediction intervals. nonneg Logical. default TRUE enforces nonnegative predictions hard-thresholding 0. quantile_by_key Character vector. Groups residuals listed keys calculating residual quantiles. See by_key argument layer_residual_quantiles() information. default, character(0) performs grouping.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flatline forecaster argument constructor — flatline_args_list","text":"list containing updated parameter choices.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flatline forecaster argument constructor — flatline_args_list","text":"","code":"flatline_args_list() #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 20 #>  #> $forecast_date #> NULL #>  #> $target_date #> NULL #>  #> $levels #> [1] 0.05 0.95 #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $quantile_by_key #> character(0) #>  flatline_args_list(symmetrize = FALSE) #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 20 #>  #> $forecast_date #> NULL #>  #> $target_date #> NULL #>  #> $levels #> [1] 0.05 0.95 #>  #> $symmetrize #> [1] FALSE #>  #> $nonneg #> [1] TRUE #>  #> $quantile_by_key #> character(0) #>  flatline_args_list(levels = c(.1, .3, .7, .9), min_train_window = 120) #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 120 #>  #> $forecast_date #> NULL #>  #> $target_date #> NULL #>  #> $levels #> [1] 0.1 0.3 0.7 0.9 #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $quantile_by_key #> character(0) #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict the future with today's value — flatline_forecaster","title":"Predict the future with today's value — flatline_forecaster","text":"simple forecasting model epiprocess::epi_df data. uses recent observation forcast future date, produces intervals based quantiles residuals \"flatline\" forecast available training data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict the future with today's value — flatline_forecaster","text":"","code":"flatline_forecaster(epi_data, outcome, args_list = flatline_args_list())"},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict the future with today's value — flatline_forecaster","text":"epi_data epiprocess::epi_df outcome scalar character column name wish predict. args_list list dditional arguments created flatline_args_list() constructor function.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict the future with today's value — flatline_forecaster","text":"data frame point (optionally interval) forecasts single ahead (unique horizon) unique combination key_vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_forecaster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict the future with today's value — flatline_forecaster","text":"default, predictive intervals computed separately combination key values (geo_value + additional keys) epi_data argument. forecaster similar used COVID19ForecastHub","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/flatline_forecaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict the future with today's value — flatline_forecaster","text":"","code":"jhu <- case_death_rate_subset %>%   dplyr::filter(time_value >= as.Date(\"2021-12-01\"))  out <- flatline_forecaster(jhu, \"death_rate\")"},{"path":"https://cmu-delphi.github.io/epipredict/reference/frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Create frosting for postprocessing predictions — frosting","title":"Create frosting for postprocessing predictions — frosting","text":"generates postprocessing container (much like recipes::recipe()) hold steps postprocessing predictions.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create frosting for postprocessing predictions — frosting","text":"","code":"frosting(layers = NULL, requirements = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create frosting for postprocessing predictions — frosting","text":"layers Must NULL. requirements Must NULL.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/frosting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create frosting for postprocessing predictions — frosting","text":"frosting object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/frosting.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create frosting for postprocessing predictions — frosting","text":"arguments currently placeholders must NULL","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/frosting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create frosting for postprocessing predictions — frosting","text":"","code":"library(dplyr) library(recipes)  # Toy example to show that frosting can be created and added for postprocessing  f <- frosting()  wf <- epi_workflow() %>% add_frosting(f)  # A more realistic example jhu <- case_death_rate_subset %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE)  wf <- epi_workflow(r, parsnip::linear_reg()) %>% parsnip::fit(jhu) latest <- get_test_data(recipe = r, x = jhu)  f <- frosting() %>%   layer_predict() %>%   layer_naomit(.pred)  wf1 <- wf %>% add_frosting(f)  p <- predict(wf1, latest) p #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 3 #>   geo_value time_value .pred #> * <chr>     <date>     <dbl> #> 1 ak        2021-12-31 0.245 #> 2 ca        2021-12-31 0.313 #> 3 ny        2021-12-31 0.295"},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Get test data for prediction based on longest lag period — get_test_data","title":"Get test data for prediction based on longest lag period — get_test_data","text":"Based longest lag period recipe, get_test_data() creates epiprocess::epi_df columns geo_value, time_value variables original dataset, used create test data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get test data for prediction based on longest lag period — get_test_data","text":"","code":"get_test_data(recipe, x, fill_locf = FALSE, n_recent = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get test data for prediction based on longest lag period — get_test_data","text":"recipe recipe object. step added sequence operations recipe. x data frame, tibble, epi_df data set. fill_locf Logical. use locf fill missing data? n_recent Integer NULL. filling missing data locf=TRUE, far back willing tolerate missing data? Larger values allow filling. default NULL determine maximum lags used recipe. example, suppose n_recent = 3, 3 recent observations region NA’s, won’t able fill anything, error message thrown.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get test data for prediction based on longest lag period — get_test_data","text":"tibble columns geo_value, time_value, additional keys, well variables original dataset.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get test data for prediction based on longest lag period — get_test_data","text":"also optionally fills missing values using last-observation-carried-forward (LOCF) method. possible (say NA's location), produce error suggesting alternative options handle missing values advanced techniques.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get test data for prediction based on longest lag period — get_test_data","text":"","code":"# create recipe  rec <- epi_recipe(case_death_rate_subset) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14))  get_test_data(recipe = rec, x = case_death_rate_subset) #> An `epi_df` object, 840 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 840 × 4 #>    geo_value time_value case_rate death_rate #>  * <chr>     <date>         <dbl>      <dbl> #>  1 ak        2021-12-17      23.1      1.19  #>  2 ak        2021-12-18      23.1      1.19  #>  3 ak        2021-12-19      23.1      1.19  #>  4 ak        2021-12-20      23.2      1.17  #>  5 ak        2021-12-21      23.2      1.17  #>  6 ak        2021-12-22      20.3      1.72  #>  7 ak        2021-12-23      20.3      1.72  #>  8 ak        2021-12-24      12.6      0.593 #>  9 ak        2021-12-25      12.6      0.593 #> 10 ak        2021-12-26      12.6      0.593 #> # … with 830 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the names from a data frame via tidy select — grab_names","title":"Get the names from a data frame via tidy select — grab_names","text":"Given data.frame, use <tidy-select> syntax choose variables. Return names variables","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the names from a data frame via tidy select — grab_names","text":"","code":"grab_names(dat, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the names from a data frame via tidy select — grab_names","text":"dat data.frame ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the names from a data frame via tidy select — grab_names","text":"character vector","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the names from a data frame via tidy select — grab_names","text":"internal function, checks performed.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the names from a data frame via tidy select — grab_names","text":"","code":"df <- data.frame(a = 1, b = 2, cc = rep(NA, 3)) grab_names(df, dplyr::starts_with(\"c\")) #> [1] \"cc\""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for epi_recipe — is_epi_recipe","title":"Test for epi_recipe — is_epi_recipe","text":"Test epi_recipe","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for epi_recipe — is_epi_recipe","text":"","code":"is_epi_recipe(x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for epi_recipe — is_epi_recipe","text":"x object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for epi_recipe — is_epi_recipe","text":"TRUE object inherits epi_recipe.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for an epi_workflow — is_epi_workflow","title":"Test for an epi_workflow — is_epi_workflow","text":"Test epi_workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for an epi_workflow — is_epi_workflow","text":"","code":"is_epi_workflow(x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for an epi_workflow — is_epi_workflow","text":"x object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for an epi_workflow — is_epi_workflow","text":"TRUE object inherits epi_workflow.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer-processors.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract, validate, or detect layers of frosting — extract_layers","title":"Extract, validate, or detect layers of frosting — extract_layers","text":"functions mainly internal. can access validate different layers frosting.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer-processors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract, validate, or detect layers of frosting — extract_layers","text":"","code":"extract_layers(x, ...)  # S3 method for frosting extract_layers(x, ...)  # S3 method for workflow extract_layers(x, ...)  is_layer(x)  validate_layer(x, ..., arg = \"`x`\", call = caller_env())  detect_layer(x, name, ...)  # S3 method for frosting detect_layer(x, name, ...)  # S3 method for workflow detect_layer(x, name, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer-processors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract, validate, or detect layers of frosting — extract_layers","text":"x epi_workflow, frosting, layer object ... additional arguments possible future methods arg name input (error reporting) call environment (error reporting) name layer name detect","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer-processors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract, validate, or detect layers of frosting — extract_layers","text":"logical validators/detectors list layers extractors","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer-processors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract, validate, or detect layers of frosting — extract_layers","text":"","code":"f <- frosting() %>% layer_predict() wf <- epi_workflow(postprocessor = f)  is_layer(layer(\"what_the_what\")) #> [1] TRUE detect_layer(f, \"layer_predict\") #> [1] TRUE detect_layer(wf, \"layer_predict\") #> [1] TRUE  extract_layers(f) #> [[1]] #> $type #> NULL #>  #> $opts #> list() #>  #> $dots_list #> list() #>  #> $id #> [1] \"predict_default_SjP7z\" #>  #> attr(,\"class\") #> [1] \"layer_predict\" \"layer\"         #>  extract_layers(wf) #> [[1]] #> $type #> NULL #>  #> $opts #> list() #>  #> $dots_list #> list() #>  #> $id #> [1] \"predict_default_SjP7z\" #>  #> attr(,\"class\") #> [1] \"layer_predict\" \"layer\"         #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer.html","id":null,"dir":"Reference","previous_headings":"","what":"layer sets the class of the layer — layer","title":"layer sets the class of the layer — layer","text":"layer sets class layer","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"layer sets the class of the layer — layer","text":"","code":"layer(subclass, ..., .prefix = \"layer_\")"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"layer sets the class of the layer — layer","text":"subclass character string resulting class. example, subclass = \"blah\" layer object returned class layer_blah. ... arguments operator returned. .prefix Prefix subclass created.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"layer sets the class of the layer — layer","text":"updated layer new class","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_forecast_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Postprocessing step to add the forecast date — layer_add_forecast_date","title":"Postprocessing step to add the forecast date — layer_add_forecast_date","text":"Postprocessing step add forecast date","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_forecast_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Postprocessing step to add the forecast date — layer_add_forecast_date","text":"","code":"layer_add_forecast_date(   frosting,   forecast_date = NULL,   id = rand_id(\"add_forecast_date\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_forecast_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Postprocessing step to add the forecast date — layer_add_forecast_date","text":"frosting frosting postprocessor forecast_date forecast date add column epi_df. cases, specified form \"yyyy-mm-dd\". Note forecast date left unspecified, set maximum time value test data processing (ex. leads lags) applied. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_forecast_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Postprocessing step to add the forecast date — layer_add_forecast_date","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_forecast_date.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Postprocessing step to add the forecast date — layer_add_forecast_date","text":"use function, either specify forecast date leave forecast date unspecifed . latter case, forecast date set maximum time value processed test data. case, forecast date less recent update date data (ie. as_of value), appropriate warning thrown.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_forecast_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Postprocessing step to add the forecast date — layer_add_forecast_date","text":"","code":"jhu <- case_death_rate_subset %>%   dplyr::filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   recipes::step_naomit(recipes::all_predictors()) %>%   recipes::step_naomit(recipes::all_outcomes(), skip = TRUE) wf <- epi_workflow(r, parsnip::linear_reg()) %>% parsnip::fit(jhu) latest <- jhu %>%   dplyr::filter(time_value >= max(time_value) - 14)  # Specify a `forecast_date` that is greater than or equal to `as_of` date f <- frosting() %>% layer_predict() %>%   layer_add_forecast_date(forecast_date = \"2022-05-31\") %>%   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f)  p1 <- predict(wf1, latest) p1 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 4 #>   geo_value time_value .pred forecast_date #> * <chr>     <date>     <dbl> <date>        #> 1 ak        2021-12-31 0.245 2022-05-31    #> 2 ca        2021-12-31 0.313 2022-05-31    #> 3 ny        2021-12-31 0.295 2022-05-31     # Specify a `forecast_date` that is less than `as_of` date f2 <- frosting() %>%   layer_predict() %>%   layer_add_forecast_date(forecast_date = \"2021-12-31\") %>%   layer_naomit(.pred) wf2 <- wf %>% add_frosting(f2)  p2 <- predict(wf2, latest) #> Warning: The forecast_date is less than the most recent update date of the data.forecast_date = 2021-12-31 while data is from 2022-05-31. p2 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 4 #>   geo_value time_value .pred forecast_date #> * <chr>     <date>     <dbl> <date>        #> 1 ak        2021-12-31 0.245 2021-12-31    #> 2 ca        2021-12-31 0.313 2021-12-31    #> 3 ny        2021-12-31 0.295 2021-12-31     # Do not specify a forecast_date  f3 <- frosting() %>%   layer_predict() %>%   layer_add_forecast_date() %>%   layer_naomit(.pred) wf3 <- wf %>% add_frosting(f3)  p3 <- predict(wf3, latest) #> Warning: The forecast_date is less than the most recent update date of the data.forecast_date = 2022-01-14 while data is from 2022-05-31. p3 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 4 #>   geo_value time_value .pred forecast_date #> * <chr>     <date>     <dbl> <date>        #> 1 ak        2021-12-31 0.245 2022-01-14    #> 2 ca        2021-12-31 0.313 2022-01-14    #> 3 ny        2021-12-31 0.295 2022-01-14"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_target_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Postprocessing step to add the target date — layer_add_target_date","title":"Postprocessing step to add the target date — layer_add_target_date","text":"Postprocessing step add target date","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_target_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Postprocessing step to add the target date — layer_add_target_date","text":"","code":"layer_add_target_date(   frosting,   target_date = NULL,   id = rand_id(\"add_target_date\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_target_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Postprocessing step to add the target date — layer_add_target_date","text":"frosting frosting postprocessor target_date target date add column epi_df. default, maximum time_value processed test data plus ahead, ahead specified preprocessing (likely step_epi_ahead). user may override date (usually form \"yyyy-mm-dd\"). id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_target_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Postprocessing step to add the target date — layer_add_target_date","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_target_date.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Postprocessing step to add the target date — layer_add_target_date","text":"default, function assumes value ahead specified preprocessing step (likely step_epi_ahead). , ahead added maximum time_value test data get target date.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_add_target_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Postprocessing step to add the target date — layer_add_target_date","text":"","code":"jhu <- case_death_rate_subset %>%   dplyr::filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   recipes::step_naomit(recipes::all_predictors()) %>%   recipes::step_naomit(recipes::all_outcomes(), skip = TRUE) wf <- epi_workflow(r, parsnip::linear_reg()) %>% parsnip::fit(jhu) latest <- jhu %>%   dplyr::filter(time_value >= max(time_value) - 14)  # Use ahead from preprocessing f <- frosting() %>% layer_predict() %>%   layer_add_target_date() %>% layer_naomit(.pred) wf1 <- wf %>% add_frosting(f)  p <- predict(wf1, latest) p #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 4 #>   geo_value time_value .pred target_date #> * <chr>     <date>     <dbl> <date>      #> 1 ak        2021-12-31 0.245 2022-01-21  #> 2 ca        2021-12-31 0.313 2022-01-21  #> 3 ny        2021-12-31 0.295 2022-01-21   # Override default behaviour by specifying own target date f2 <- frosting() %>% layer_predict() %>% layer_add_target_date(target_date = \"2022-01-08\") %>% layer_naomit(.pred) wf2 <- wf %>% add_frosting(f2)  p2 <- predict(wf2, latest) p2 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 4 #>   geo_value time_value .pred target_date #> * <chr>     <date>     <dbl> <date>      #> 1 ak        2021-12-31 0.245 2022-01-08  #> 2 ca        2021-12-31 0.313 2022-01-08  #> 3 ny        2021-12-31 0.295 2022-01-08"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_naomit.html","id":null,"dir":"Reference","previous_headings":"","what":"Omit NAs from predictions or other columns — layer_naomit","title":"Omit NAs from predictions or other columns — layer_naomit","text":"Omit NAs predictions columns","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_naomit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Omit NAs from predictions or other columns — layer_naomit","text":"","code":"layer_naomit(frosting, ..., .flag = TRUE, id = rand_id(\"naomit\"))"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_naomit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Omit NAs from predictions or other columns — layer_naomit","text":"frosting frosting postprocessor ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables. Typical usage .pred remove rows NA predictions. .flag logical determine layer added. Passed add_layer(). Default TRUE. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_naomit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Omit NAs from predictions or other columns — layer_naomit","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_naomit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Omit NAs from predictions or other columns — layer_naomit","text":"","code":"jhu <- case_death_rate_subset %>%   dplyr::filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   recipes::step_naomit(recipes::all_predictors()) %>%   recipes::step_naomit(recipes::all_outcomes(), skip = TRUE)  wf <- epi_workflow(r, parsnip::linear_reg()) %>%  parsnip::fit(jhu)  latest <- get_test_data(recipe = r, x = jhu)  f <- epipredict:::frosting() %>%      layer_predict() %>%      layer_naomit(.pred)  wf1 <- wf %>% epipredict:::add_frosting(f)  p <- predict(wf1, latest) p #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 3 #>   geo_value time_value .pred #> * <chr>     <date>     <dbl> #> 1 ak        2021-12-31 0.245 #> 2 ca        2021-12-31 0.313 #> 3 ny        2021-12-31 0.295"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_population_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert per-capita predictions to raw scale — layer_population_scaling","title":"Convert per-capita predictions to raw scale — layer_population_scaling","text":"layer_population_scaling creates specification frosting layer \"undo\" per-capita scaling. Typical usage load dataset contains state-level population, use convert predictions made rate-scale model raw scale multiplying population. Although, worth noting nothing special \"population\". function can used scale variable. Population standard use case epidemiology forecasting scenario. value passed multiply selected variables rate_rescaling argument common divisor selected variables.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_population_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert per-capita predictions to raw scale — layer_population_scaling","text":"","code":"layer_population_scaling(   frosting,   ...,   df,   by = NULL,   df_pop_col,   rate_rescaling = 1,   create_new = TRUE,   suffix = \"_scaled\",   .flag = TRUE,   id = rand_id(\"population_scaling\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_population_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert per-capita predictions to raw scale — layer_population_scaling","text":"frosting frosting postprocessor. layer added sequence operations frosting. ... One selector functions scale variables step. See selections() details. df data frame contains population data used inverting existing scaling. (possibly named) character vector variables join . NULL, default, function perform natural join, using variables common across epi_df produced predict() call user-provided dataset. columns epi_df df name (included ), .df added one user-provided data disambiguate. join different variables epi_df df, use named vector. example, = c(\"geo_value\" = \"states\") match epi_df$geo_value df$states. join multiple variables, use vector length > 1. example, = c(\"geo_value\" = \"states\", \"county\" = \"county\") match epi_df$geo_value df$states epi_df$county df$county. See dplyr::left_join() details. df_pop_col name column data frame df contains population data used scaling. rate_rescaling Sometimes rates \"per 100K\" \"per 1M\" rather \"per person\". Adjustments can made . example, original rate \"per 100K\", set rate_rescaling = 1e5 get counts back. create_new TRUE create new column keep original column epi_df. suffix character. suffix added column name create_new = TRUE. Default \"_original\". .flag logical determine layer added. Passed add_layer(). Default TRUE. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_population_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert per-capita predictions to raw scale — layer_population_scaling","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_population_scaling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert per-capita predictions to raw scale — layer_population_scaling","text":"","code":"library(epiprocess) jhu <- epiprocess::jhu_csse_daily_subset %>%   dplyr::filter(time_value > \"2021-11-01\", geo_value %in% c(\"ca\", \"ny\")) %>%   dplyr::select(geo_value, time_value, cases)  pop_data = data.frame(states = c(\"ca\", \"ny\"), value = c(20000, 30000))  r <- epi_recipe(jhu) %>%   step_population_scaling(df = pop_data,                           df_pop_col = \"value\",                           by = c(\"geo_value\" = \"states\"),                           cases, suffix = \"_scaled\") %>%   step_epi_lag(cases_scaled, lag = c(7, 14)) %>%   step_epi_ahead(cases_scaled, ahead = 7, role = \"outcome\") %>%   step_epi_naomit()  f <- frosting() %>%   layer_predict() %>%   layer_threshold(.pred) %>%   layer_naomit(.pred) %>%   layer_population_scaling(.pred, df = pop_data,                            by =  c(\"geo_value\" = \"states\"),                            df_pop_col = \"value\")  wf <- epi_workflow(r,                    parsnip::linear_reg()) %>%   parsnip::fit(jhu) %>%   add_frosting(f)  latest <- get_test_data(   recipe = r,   x = epiprocess::jhu_csse_daily_subset %>%     dplyr::filter(time_value > \"2021-11-01\",                   geo_value %in% c(\"ca\", \"ny\")) %>%     dplyr::select(geo_value, time_value, cases))  predict(wf, latest) #> An `epi_df` object, 2 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-23 20:17:07 #>  #> # A tibble: 2 × 4 #>   geo_value time_value .pred .pred_scaled #> * <chr>     <date>     <dbl>        <dbl> #> 1 ca        2021-12-31  4.25       84967. #> 2 ny        2021-12-31  5.93      177783."},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction layer for postprocessing — layer_predict","title":"Prediction layer for postprocessing — layer_predict","text":"Implements prediction fitted epi_workflow. One may want different types prediction, potentially apply amount postprocessing. typically first layer frosting postprocessor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction layer for postprocessing — layer_predict","text":"","code":"layer_predict(   frosting,   type = NULL,   opts = list(),   ...,   .flag = TRUE,   id = rand_id(\"predict_default\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction layer for postprocessing — layer_predict","text":"frosting frosting object #' @param .flag logical determine layer added. Passed add_layer(). Default TRUE. type single character value NULL. Possible values \"numeric\", \"class\", \"prob\", \"conf_int\", \"pred_int\", \"quantile\", \"time\", \"hazard\", \"survival\", \"raw\". NULL, predict() choose appropriate value based model's mode. opts list optional arguments underlying predict function used type = \"raw\". list include options model object new data predicted. ... Arguments underlying model's prediction function passed (see opts). parsnip related options can passed, depending value type. Possible arguments : interval: types \"survival\" \"quantile\", interval estimates added, available? Options \"none\" \"confidence\". level: types \"conf_int\", \"pred_int\", \"survival\" parameter tail area intervals (e.g. confidence level confidence intervals). Default value 0.95. std_error: add standard error fit prediction (scale linear predictors) types \"conf_int\" \"pred_int\". Default value FALSE. quantile: quantile(s) quantile regression (implemented yet) time: time(s) hazard survival probability estimates. .flag logical determine layer added. Passed add_layer(). Default TRUE. id string identifying layer","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction layer for postprocessing — layer_predict","text":"updated frosting object","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction layer for postprocessing — layer_predict","text":"","code":"library(dplyr) library(recipes)  jhu <- case_death_rate_subset %>% filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%  step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%  step_epi_ahead(death_rate, ahead = 7) %>%  step_naomit(all_predictors()) %>%  step_naomit(all_outcomes(), skip = TRUE) wf <- epi_workflow(r, parsnip::linear_reg()) %>% parsnip::fit(jhu) latest <- jhu %>%  filter(time_value >= max(time_value) - 14)  # Predict layer alone f <- frosting() %>% layer_predict() wf1 <- wf %>% add_frosting(f)  p1 <- predict(wf1, latest) p1 #> An `epi_df` object, 108 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 108 × 3 #>    geo_value time_value .pred #>    <chr>     <date>     <dbl> #>  1 ak        2021-12-10    NA #>  2 ca        2021-12-10    NA #>  3 ny        2021-12-10    NA #>  4 ak        2021-12-11    NA #>  5 ca        2021-12-11    NA #>  6 ny        2021-12-11    NA #>  7 ak        2021-12-12    NA #>  8 ca        2021-12-12    NA #>  9 ny        2021-12-12    NA #> 10 ak        2021-12-13    NA #> # … with 98 more rows  # Prediction with interval f <- frosting() %>% layer_predict(type = \"pred_int\") wf2 <- wf %>% add_frosting(f)  p2 <- predict(wf2, latest) p2 #> An `epi_df` object, 108 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 108 × 4 #>    geo_value time_value .pred_lower .pred_upper #>    <chr>     <date>           <dbl>       <dbl> #>  1 ak        2021-12-10          NA          NA #>  2 ca        2021-12-10          NA          NA #>  3 ny        2021-12-10          NA          NA #>  4 ak        2021-12-11          NA          NA #>  5 ca        2021-12-11          NA          NA #>  6 ny        2021-12-11          NA          NA #>  7 ak        2021-12-12          NA          NA #>  8 ca        2021-12-12          NA          NA #>  9 ny        2021-12-12          NA          NA #> 10 ak        2021-12-13          NA          NA #> # … with 98 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predictive_distn.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns predictive distributions — layer_predictive_distn","title":"Returns predictive distributions — layer_predictive_distn","text":"function calculates approximation parametric predictive distribution. Predictive distributions linear models require x* (X'X)^{-1} x* along degrees freedom. function approximates . reasonably accurate models fit using lm new point x* far bulk data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predictive_distn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns predictive distributions — layer_predictive_distn","text":"","code":"layer_predictive_distn(   frosting,   ...,   dist_type = c(\"gaussian\", \"student_t\"),   truncate = c(-Inf, Inf),   name = \".pred_distn\",   .flag = TRUE,   id = rand_id(\"predictive_distn\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predictive_distn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns predictive distributions — layer_predictive_distn","text":"frosting frosting postprocessor ... Unused, include consistency layers. dist_type Gaussian Student's t predictive intervals truncate truncate distribution interval name character. name output column. .flag logical determine layer added. Passed add_layer(). Default TRUE. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predictive_distn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns predictive distributions — layer_predictive_distn","text":"updated frosting postprocessor additional columns residual quantiles added prediction","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_predictive_distn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns predictive distributions — layer_predictive_distn","text":"","code":"jhu <- case_death_rate_subset %>%   dplyr::filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, parsnip::linear_reg()) %>%  parsnip::fit(jhu)  latest <- get_test_data(recipe = r, x = jhu)  f <- frosting() %>%   layer_predict() %>%   layer_predictive_distn() %>%   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f)  p <- predict(wf1, latest) p #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 3 × 4 #>   geo_value time_value .pred    .pred_distn #> * <chr>     <date>     <dbl>         <dist> #> 1 ak        2021-12-31 0.245 N(0.24, 0.093) #> 2 ca        2021-12-31 0.313 N(0.31, 0.093) #> 3 ny        2021-12-31 0.295 N(0.29, 0.093)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_residual_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates predictions based on residual quantiles — layer_residual_quantiles","title":"Creates predictions based on residual quantiles — layer_residual_quantiles","text":"Creates predictions based residual quantiles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_residual_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates predictions based on residual quantiles — layer_residual_quantiles","text":"","code":"layer_residual_quantiles(   frosting,   ...,   probs = c(0.05, 0.95),   symmetrize = TRUE,   by_key = character(0L),   name = \".pred_distn\",   .flag = TRUE,   id = rand_id(\"residual_quantiles\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_residual_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates predictions based on residual quantiles — layer_residual_quantiles","text":"frosting frosting postprocessor ... Unused, include consistency layers. probs numeric vector probabilities values (0,1) referring desired quantile. symmetrize logical. TRUE interval symmetric. by_key character vector keys group residuals calculating quantiles. default, c() performs grouping. name character. name output column. .flag logical determine layer added. Passed add_layer(). Default TRUE. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_residual_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates predictions based on residual quantiles — layer_residual_quantiles","text":"updated frosting postprocessor additional columns residual quantiles added prediction","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_residual_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates predictions based on residual quantiles — layer_residual_quantiles","text":"","code":"jhu <- case_death_rate_subset %>%   dplyr::filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, parsnip::linear_reg()) %>%  parsnip::fit(jhu)  latest <- get_test_data(recipe = r, x = jhu)  f <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles(probs = c(0.0275, 0.975), symmetrize = FALSE) %>%   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f)  p <- predict(wf1, latest)  f2 <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles(probs = c(0.3, 0.7), by_key = \"geo_value\") %>%   layer_naomit(.pred) wf2 <- wf %>% add_frosting(f2)  p2 <- predict(wf2, latest)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_threshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower and upper thresholds for predicted values — layer_threshold","title":"Lower and upper thresholds for predicted values — layer_threshold","text":"postprocessing step used set prediction values smaller lower threshold higher upper threshold equal threshold values.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_threshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower and upper thresholds for predicted values — layer_threshold","text":"","code":"layer_threshold(   frosting,   ...,   lower = 0,   upper = Inf,   .flag = TRUE,   id = rand_id(\"threshold\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_threshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lower and upper thresholds for predicted values — layer_threshold","text":"frosting frosting postprocessor ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables. Typical usage .pred threshold predictions range (say, nonnegative). lower Lower threshold prediction values. , predictions less lower bound set . Default value 0. upper Upper threshold prediction values. , predictions greater upper bound set . Default value Inf. .flag logical determine layer added. Passed add_layer(). Default TRUE. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_threshold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lower and upper thresholds for predicted values — layer_threshold","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/layer_threshold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lower and upper thresholds for predicted values — layer_threshold","text":"","code":"library(dplyr) library(recipes)  jhu <- case_death_rate_subset %>%   filter(time_value < \"2021-03-08\", geo_value %in% c(\"ak\", \"ca\", \"ar\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE) wf <- epi_workflow(r, parsnip::linear_reg()) %>%   parsnip::fit(jhu)  latest <- jhu %>%   filter(time_value >= max(time_value) - 14)  f <- frosting() %>%   layer_predict() %>%   layer_threshold(.pred, lower = 0.180, upper = 0.310) wf <- wf %>% add_frosting(f) p <- predict(wf, latest) p #> An `epi_df` object, 108 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 108 × 3 #>    geo_value time_value .pred #>  * <chr>     <date>     <dbl> #>  1 ak        2021-02-14    NA #>  2 ar        2021-02-14    NA #>  3 ca        2021-02-14    NA #>  4 ak        2021-02-15    NA #>  5 ar        2021-02-15    NA #>  6 ca        2021-02-15    NA #>  7 ak        2021-02-16    NA #>  8 ar        2021-02-16    NA #>  9 ca        2021-02-16    NA #> 10 ak        2021-02-17    NA #> # … with 98 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/reference/nested_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn a a vector of quantile distributions into a list-col — nested_quantiles","title":"Turn a a vector of quantile distributions into a list-col — nested_quantiles","text":"Turn vector quantile distributions list-col","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/nested_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn a a vector of quantile distributions into a list-col — nested_quantiles","text":"","code":"nested_quantiles(x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/nested_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn a a vector of quantile distributions into a list-col — nested_quantiles","text":"x distribution containing dist_quantiles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/nested_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn a a vector of quantile distributions into a list-col — nested_quantiles","text":"list-col","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/nested_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn a a vector of quantile distributions into a list-col — nested_quantiles","text":"","code":"edf <- case_death_rate_subset[1:3,] edf$q <- dist_quantiles(list(1:5, 2:4, 3:10), list(1:5/6, 2:4/5, 3:10/11))  edf_nested <- edf %>% dplyr::mutate(q = nested_quantiles(q)) edf_nested %>% tidyr::unnest(q) #> An `epi_df` object, 16 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 16 × 6 #>    geo_value time_value case_rate death_rate     q   tau #>  * <chr>     <date>         <dbl>      <dbl> <dbl> <dbl> #>  1 ak        2020-12-31      35.9      0.158     1 0.167 #>  2 ak        2020-12-31      35.9      0.158     2 0.333 #>  3 ak        2020-12-31      35.9      0.158     3 0.5   #>  4 ak        2020-12-31      35.9      0.158     4 0.667 #>  5 ak        2020-12-31      35.9      0.158     5 0.833 #>  6 al        2020-12-31      65.1      0.438     2 0.4   #>  7 al        2020-12-31      65.1      0.438     3 0.6   #>  8 al        2020-12-31      65.1      0.438     4 0.8   #>  9 ar        2020-12-31      66.0      1.27      3 0.273 #> 10 ar        2020-12-31      66.0      1.27      4 0.364 #> 11 ar        2020-12-31      66.0      1.27      5 0.455 #> 12 ar        2020-12-31      66.0      1.27      6 0.545 #> 13 ar        2020-12-31      66.0      1.27      7 0.636 #> 14 ar        2020-12-31      66.0      1.27      8 0.727 #> 15 ar        2020-12-31      66.0      1.27      9 0.818 #> 16 ar        2020-12-31      66.0      1.27     10 0.909"},{"path":"https://cmu-delphi.github.io/epipredict/reference/new_epi_recipe_blueprint.html","id":null,"dir":"Reference","previous_headings":"","what":"Recipe blueprint that accounts for epi_df panel data — new_epi_recipe_blueprint","title":"Recipe blueprint that accounts for epi_df panel data — new_epi_recipe_blueprint","text":"Used simplicity. See hardhat::new_recipe_blueprint() hardhat::default_recipe_blueprint() details.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/new_epi_recipe_blueprint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recipe blueprint that accounts for epi_df panel data — new_epi_recipe_blueprint","text":"","code":"new_epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   composition = \"tibble\",   ptypes = NULL,   recipe = NULL,   ...,   subclass = character() )  epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   composition = \"tibble\" )  default_epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   composition = \"tibble\" )  new_default_epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   composition = \"tibble\",   ptypes = NULL,   recipe = NULL,   extra_role_ptypes = NULL,   ...,   subclass = character() )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/new_epi_recipe_blueprint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recipe blueprint that accounts for epi_df panel data — new_epi_recipe_blueprint","text":"intercept logical. intercept included processed data? information used process function mold forge function list. allow_novel_levels logical. novel factor levels allowed prediction time? information used clean function forge function list, passed scream(). fresh already trained operations re-trained prep() called? composition Either \"tibble\", \"matrix\", \"dgCMatrix\" format processed predictors. \"matrix\" \"dgCMatrix\" chosen, predictors must numeric preprocessing method applied; otherwise error thrown. ptypes Either NULL, named list 2 elements, predictors outcomes, 0-row tibbles. ptypes generated automatically mold() time used validate new_data prediction time. recipe Either NULL, unprepped recipe. argument set automatically mold() time. ... Name-value pairs additional elements blueprints subclass blueprint. subclass character vector. subclasses blueprint. extra_role_ptypes named list. names unique non-standard recipe roles (.e. everything except \"predictors\" \"outcomes\"). values prototypes original columns role. used validation forge().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/new_epi_recipe_blueprint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recipe blueprint that accounts for epi_df panel data — new_epi_recipe_blueprint","text":"recipe blueprint.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/new_epi_recipe_blueprint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recipe blueprint that accounts for epi_df panel data — new_epi_recipe_blueprint","text":"bake_dependent_roles automatically set epi_df defaults.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://cmu-delphi.github.io/epipredict/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict from an epi_workflow — predict-epi_workflow","title":"Predict from an epi_workflow — predict-epi_workflow","text":"predict() method fit epi_workflow object. nice thing predicting epi_workflow : Preprocess new_data using preprocessing method specified workflow created fit. accomplished using hardhat::forge(), apply formula preprocessing call recipes::bake() recipe supplied. Call parsnip::predict.model_fit() using underlying fit parsnip model. Ensure returned object epiprocess::epi_df possible. Specifically, output time_value geo_value columns well prediction.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict from an epi_workflow — predict-epi_workflow","text":"","code":"# S3 method for epi_workflow predict(object, new_data, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict from an epi_workflow — predict-epi_workflow","text":"object epi_workflow fit workflows::fit.workflow() new_data data frame containing new predictors preprocess predict ... Arguments underlying model's prediction function passed (see opts). parsnip related options can passed, depending value type. Possible arguments : interval: types \"survival\" \"quantile\", interval estimates added, available? Options \"none\" \"confidence\". level: types \"conf_int\", \"pred_int\", \"survival\" parameter tail area intervals (e.g. confidence level confidence intervals). Default value 0.95. std_error: add standard error fit prediction (scale linear predictors) types \"conf_int\" \"pred_int\". Default value FALSE. quantile: quantile(s) quantile regression (implemented yet) time: time(s) hazard survival probability estimates.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict from an epi_workflow — predict-epi_workflow","text":"data frame model predictions, many rows new_data . new_data epi_df data frame time_value geo_value columns, result well.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict from an epi_workflow — predict-epi_workflow","text":"","code":"library(dplyr) library(parsnip) library(recipes)  jhu <- case_death_rate_subset  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE)  wf <- epi_workflow(r, linear_reg()) %>% fit(jhu)  latest <- jhu %>% filter(time_value >= max(time_value) - 14)  preds <- predict(wf, latest) %>%   filter(!is.na(.pred))  preds #> An `epi_df` object, 56 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 56 × 3 #>    geo_value time_value     .pred #>  * <chr>     <date>         <dbl> #>  1 ak        2021-12-31  0.378    #>  2 al        2021-12-31  0.280    #>  3 ar        2021-12-31  0.452    #>  4 as        2021-12-31 -0.000475 #>  5 az        2021-12-31  0.657    #>  6 ca        2021-12-31  0.293    #>  7 co        2021-12-31  0.569    #>  8 ct        2021-12-31  0.641    #>  9 dc        2021-12-31  1.02     #> 10 de        2021-12-31  0.733    #> # … with 46 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/reference/slather.html","id":null,"dir":"Reference","previous_headings":"","what":"Spread a layer of frosting on a fitted workflow — slather","title":"Spread a layer of frosting on a fitted workflow — slather","text":"Slathering frosting means implement postprocessing layer. creating new postprocessing layer, must implement S3 method function","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/slather.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spread a layer of frosting on a fitted workflow — slather","text":"","code":"slather(object, components, the_fit, the_recipe, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/slather.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spread a layer of frosting on a fitted workflow — slather","text":"object workflow frosting postprocessing steps components list components containing model information. updated returned layer. mold - output calling hardhat::mold() workflow. contains information preprocessing, including recipe. forged - output calling hardhat::forge() workflow. predictors outcomes new_data. three components predictors, outcomes (new_data), extras (usually rest data, including keys). keys - put keys (time_value, geo_value, others) ease. the_fit fitted model object returned calling parsnip::fit() the_recipe epi_recipe preprocessor ... additional arguments used methods. Currently unused.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/slather.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spread a layer of frosting on a fitted workflow — slather","text":"components list. format applying updates.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/state_census.html","id":null,"dir":"Reference","previous_headings":"","what":"State population data — state_census","title":"State population data — state_census","text":"Data set state populations, 2019 US Census.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/state_census.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"State population data — state_census","text":"","code":"state_census"},{"path":"https://cmu-delphi.github.io/epipredict/reference/state_census.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"State population data — state_census","text":"Data frame 57 rows (including one United States whole, plus District Columbia, Puerto Rico Commonwealth, American Samoa, Guam, U.S. Virgin Islands, Northern Mariana, Islands). fips FIPS code name Full name state territory pop Estimate location's resident population 2019. abbr Postal abbreviation location","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/state_census.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"State population data — state_census","text":"United States Census Bureau, https://www2.census.gov/programs-surveys/popest/datasets/2010-2019/counties/totals/co-est2019-alldata.pdf, https://www.census.gov/data/tables/time-series/demo/popest/2010s-total-puerto-rico-municipios.html, https://www.census.gov/data/tables/2010/dec/2010-island-areas.html","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified NA omission wrapper function for recipes — step_epi_naomit","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"Unified NA omission wrapper function recipes","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"","code":"step_epi_naomit(recipe)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"recipe Recipe used omission steps","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"Omits NA's predictors outcomes training time fit model. Also omits associated predictors outcomes prediction time due lack response avoidance data loss.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"","code":"case_death_rate_subset %>%  epi_recipe() %>%  step_epi_naomit() #> Recipe #>  #> Inputs: #>  #>        role #variables #>   geo_value          1 #>         raw          2 #>  time_value          1 #>  #> Operations: #>  #> Removing rows with NA values in all_predictors() #> Removing rows with NA values in all_outcomes()"},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a shifted predictor — step_epi_lag","title":"Create a shifted predictor — step_epi_lag","text":"step_epi_lag step_epi_ahead create specification recipe step add new columns shifted data. former created lag column, latter create lead column. Shifted data default include NA values shift induced. can properly removed step_epi_naomit(), may specify alternative filler value default argument.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a shifted predictor — step_epi_lag","text":"","code":"step_epi_lag(   recipe,   ...,   role = \"predictor\",   trained = FALSE,   lag = 1,   prefix = \"lag_\",   default = NA,   columns = NULL,   skip = FALSE,   id = rand_id(\"epi_lag\") )  step_epi_ahead(   recipe,   ...,   role = \"outcome\",   trained = FALSE,   ahead = 1,   prefix = \"ahead_\",   default = NA,   columns = NULL,   skip = FALSE,   id = rand_id(\"epi_ahead\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a shifted predictor — step_epi_lag","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See selections() details. role model terms created step, analysis role assigned? lag default predictor ahead outcome. trained logical indicate quantities preprocessing estimated. lag, ahead vector integers. specified column lag lead value vector. Lag integers must nonnegative, ahead integers must positive. prefix prefix indicate type variable default Determines fills empty rows left leading/lagging (defaults NA). columns character string variable names populated (eventually) terms argument. skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a shifted predictor — step_epi_lag","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_shift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a shifted predictor — step_epi_lag","text":"step assumes data already proper sequential order shifting. prefix id arguments unchangeable ensure code runs properly avoid inconsistency naming. step_epi_ahead, always set \"ahead_\" \"epi_ahead\" respectively, step_epi_lag, set \"lag_\" \"epi_lag, respectively.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a shifted predictor — step_epi_lag","text":"","code":"r <- epi_recipe(case_death_rate_subset) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(death_rate, lag = c(0,7,14)) r #> Recipe #>  #> Inputs: #>  #>        role #variables #>   geo_value          1 #>         raw          2 #>  time_value          1 #>  #> Operations: #>  #> Leading death_rate by 7 #> Lagging death_rate by 0, 7, 14"},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_population_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert raw scale predictions to per-capita — step_population_scaling","title":"Convert raw scale predictions to per-capita — step_population_scaling","text":"step_population_scaling creates specification recipe step perform per-capita scaling. Typical usage load dataset contains state-level population, use convert predictions made raw scale model rate-scale dividing population. Although, worth noting nothing special \"population\". function can used scale variable. Population standard use case epidemiology forecasting scenario. value passed divide selected variables rate_rescaling argument common multiplier selected variables.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_population_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert raw scale predictions to per-capita — step_population_scaling","text":"","code":"step_population_scaling(   recipe,   ...,   role = \"predictor\",   trained = FALSE,   df,   by = NULL,   df_pop_col,   rate_rescaling = 1,   create_new = TRUE,   suffix = \"_scaled\",   columns = NULL,   skip = FALSE,   id = rand_id(\"population_scaling\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_population_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert raw scale predictions to per-capita — step_population_scaling","text":"recipe recipe object. step added sequence operations recipe. recipe contain information epi_df column names. ... One selector functions scale variables step. See selections() details. role model terms created step, analysis role assigned? default, new columns created step original variables used predictors model. options can ard limited \"outcome\". trained logical indicate quantities preprocessing estimated. df data frame contains population data used inverting existing scaling. (possibly named) character vector variables join . NULL, default, function perform natural join, using variables common across epi_df produced predict() call user-provided dataset. columns epi_df df name (included ), .df added one user-provided data disambiguate. join different variables epi_df df, use named vector. example, = c(\"geo_value\" = \"states\") match epi_df$geo_value df$states. join multiple variables, use vector length > 1. example, = c(\"geo_value\" = \"states\", \"county\" = \"county\") match epi_df$geo_value df$states epi_df$county df$county. See dplyr::left_join() details. df_pop_col name column data frame df contains population data used scaling. one column. rate_rescaling Sometimes raw scales \"per 100K\" \"per 1M\". Adjustments can made . example, original scale \"per 100K\", set rate_rescaling = 1e5 get rates. create_new TRUE create new column keep original column epi_df suffix character. suffix added column name crete_new = TRUE. Default \"_scaled\". columns character string variable names populated (eventually) terms argument. skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_population_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert raw scale predictions to per-capita — step_population_scaling","text":"Scales raw data population","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_population_scaling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert raw scale predictions to per-capita — step_population_scaling","text":"","code":"library(epiprocess) library(epipredict) jhu <- epiprocess::jhu_csse_daily_subset %>%   dplyr::filter(time_value > \"2021-11-01\", geo_value %in% c(\"ca\", \"ny\")) %>%   dplyr::select(geo_value, time_value, cases)  pop_data = data.frame(states = c(\"ca\", \"ny\"), value = c(20000, 30000))  r <- epi_recipe(jhu) %>%   step_population_scaling(df = pop_data,                           df_pop_col = \"value\",                           by = c(\"geo_value\" = \"states\"),                           cases, suffix = \"_scaled\") %>%   step_epi_lag(cases_scaled, lag = c(7, 14)) %>%   step_epi_ahead(cases_scaled, ahead = 7, role = \"outcome\") %>%   step_epi_naomit()  f <- frosting() %>%   layer_predict() %>%   layer_threshold(.pred) %>%   layer_naomit(.pred) %>%   layer_population_scaling(.pred, df = pop_data,                            by =  c(\"geo_value\" = \"states\"),                            df_pop_col = \"value\")  wf <- epi_workflow(r,                    parsnip::linear_reg()) %>%   parsnip::fit(jhu) %>%   add_frosting(f)  latest <- get_test_data(    recipe = r,    x = epiprocess::jhu_csse_daily_subset %>%    dplyr::filter(time_value > \"2021-11-01\",    geo_value %in% c(\"ca\", \"ny\")) %>%    dplyr::select(geo_value, time_value, cases))   predict(wf, latest) #> An `epi_df` object, 2 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-23 20:17:07 #>  #> # A tibble: 2 × 4 #>   geo_value time_value .pred .pred_scaled #> * <chr>     <date>     <dbl>        <dbl> #> 1 ca        2021-12-31  4.25       84967. #> 2 ny        2021-12-31  5.93      177783."},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_training_window.html","id":null,"dir":"Reference","previous_headings":"","what":"Limits the size of the training window to the most recent observations — step_training_window","title":"Limits the size of the training window to the most recent observations — step_training_window","text":"step_training_window creates specification recipe step limit size training window n_recent recent observations time_value per group, groups formed based remaining epi_keys.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_training_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Limits the size of the training window to the most recent observations — step_training_window","text":"","code":"step_training_window(   recipe,   role = NA,   trained = FALSE,   n_recent = 50,   id = rand_id(\"training_window\") )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_training_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Limits the size of the training window to the most recent observations — step_training_window","text":"recipe recipe object. step added sequence operations recipe. role used step since new variables created. trained logical indicate quantities preprocessing estimated. n_recent integer value represents number recent observations kept training window per location. default value 50. id character string unique step identify .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_training_window.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Limits the size of the training window to the most recent observations — step_training_window","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_training_window.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Limits the size of the training window to the most recent observations — step_training_window","text":"Note step_epi_lead() step_epi_lag() come filtering step.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_training_window.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Limits the size of the training window to the most recent observations — step_training_window","text":"","code":"tib <- tibble::tibble( x = 1:10, y = 1:10, time_value = rep(seq(as.Date(\"2020-01-01\"), by = 1,                      length.out = 5), times = 2), geo_value = rep(c(\"ca\", \"hi\"), each = 5) ) %>% epiprocess::as_epi_df()  library(recipes) epi_recipe(y ~ x, data = tib) %>%   step_training_window(n_recent = 3) %>%   prep(tib) %>%   bake(new_data = NULL) #> An `epi_df` object, 6 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-10-27 19:14:08 #>  #> # A tibble: 6 × 4 #>       x     y time_value geo_value #> * <int> <int> <date>     <chr>     #> 1     3     3 2020-01-03 ca        #> 2     4     4 2020-01-04 ca        #> 3     5     5 2020-01-05 ca        #> 4     8     8 2020-01-03 hi        #> 5     9     9 2020-01-04 hi        #> 6    10    10 2020-01-05 hi"},{"path":"https://cmu-delphi.github.io/epipredict/news/index.html","id":"epipredict-0009000","dir":"Changelog","previous_headings":"","what":"epipredict 0.0.0.9000","title":"epipredict 0.0.0.9000","text":"Publish public easy navigation Two simple forecasters test beds Working vignette","code":""}]
